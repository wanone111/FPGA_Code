


<!DOCTYPE HTML>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta content="Vision, Library, Vitis Vision Library, Iterative Pyramidal, Corner Tracking, cornerUpdate, cornersImgToList," name="keywords" />
<meta content="Design examples Using Vitis Vision library." name="description" />
<meta content="Document" name="xlnxdocumentclass" />
<meta content="Tutorials" name="xlnxdocumenttype" />

		<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
		<link rel="stylesheet" href="https://static.cloud.coveo.com/searchui/v2.4382/css/CoveoFullSearch.css"/>
		<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<meta name="description"/>
		<meta name="keywords"/>
		<meta property="og:title" content=""/>
		<meta property="og:description"/>
		<!-- favicon -->
		<link rel="icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<link rel="shortcut icon" type="image/vnd.microsoft.icon" href="_static/favicon.ico"/>
		<!-- Fonts -->
		<link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css"/>

	<!-- OneTrust Cookies Consent Notice start for xilinx.github.io -->
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" data-document-language="true" type="text/javascript" charset="UTF-8" data-domain-script="37701bd4-e5c0-4ee3-9329-e7475d0b13a7" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for xilinx.github.io -->
		<!-- Google Tag Manager -->
	<script type="text/plain" class="optanon-category-C0002">(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
	new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
	j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
	'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
	})(window,document,'script','dataLayer','GTM-5RHQV7');</script>
	<!-- End Google Tag Manager -->
	
        <!-- Google Tag Manager -->
        <noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-5RHQV7" height="0" width="0" style="display:none;visibility:hidden" class="optanon-category-C0002"></iframe></noscript>
        <!-- End Google Tag Manager -->	

  
  
  
  

  
      <script type="text/javascript" src="_static/js/jquery.min.js"></script>
	  <script type="text/javascript" src="_static/js/gtm.js"></script>
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
    <script type="text/javascript" src="_static/js/d3dd8c60ed.js"></script>
    <script type="text/javascript" src="_static/js/common-ui-all.min.js"></script>
    <script type="text/javascript" src="_static/js/jquery-ui.min.js"></script>
    <script type="text/javascript" src="_static/js/CoveoJsSearch.Lazy.min.js"></script>
    <script type="text/javascript" src="_static/js/linkid.js"></script>
    <script type="text/javascript" src="_static/js/Searchbox.min.js"></script>
    <script type="text/javascript" src="_static/js/header-footer.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
	</head>
	<body>
		<div class="xilinx-bs3"/>
		<div class="root responsivegrid">
			<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 aem-Grid--large--16 aem-Grid--xlarge--16 aem-Grid--xxlarge--16 aem-Grid--xxxlarge--16 ">
 <div class="xilinxExperienceFragments experiencefragment aem-GridColumn aem-GridColumn--default--12">

    
    

    



<div class="xf-content-height">
    

<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
    
    <div class="header parbase aem-GridColumn aem-GridColumn--default--12"><noindex>
	<header data-component="header" class="site-header">
		<nav class="navbar navbar-default">
			<div class="container-fluid main-nav">
				<div class="row">
					<div class="navbar-column col-xs-4 col-sm-5">
						<ul class="nav navbar-nav hidden-xs">
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
								</li>
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
								</li>
							<li>
									<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
								</li>
							</ul>
							
						<ul class="nav navbar-nav hidden-sm hidden-md hidden-lg">
							<li>
									<button data-target="#header-container-0" data-function="toggle">Solutions</button>
								</li>
							<li>
									<button data-target="#header-container-1" data-function="toggle">Products</button>
								</li>
							<li>
									<button data-target="#header-container-2" data-function="toggle">Company</button>
								</li>
							</ul>
							
						<div id="header-container-0" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							<div id="header-container-1" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							<div id="header-container-2" class="menu-container">
								<div class="navbar-nav-container">
									<ul class="nav navbar-nav">
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/applications.html&#39;;">Solutions</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/products/silicon-devices.html&#39;;">Products</button>
												</li>
										<li>
												<button onclick="window.location.href=&#39;https://www.xilinx.com/about/company-overview.html&#39;;">Company</button>
												</li>
										</ul>
									<button data-function="close-menu">
										<span class="fal fa-times" aria-hidden="true"></span>
									</button>
								</div>
							</div>
							</div>
					<div class="logo-column col-xs-4 col-sm-2">
						<div class="logo">
							<a target="_blank" href="https://www.xilinx.com/">
								<img src="https://github.com/Xilinx/Image-Collateral/blob/main/xilinx-header-logo.svg?raw=true" title="Xilinx Inc"/>
							</a>
						</div>
					</div>

				</div>
			</div>
			</nav></header></noindex></div>
		
	
</div>

    
</div>
</div>

<div class="calloutBanner parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16"><div class="callout-banner">
    Xilinx is now a part of <a target="_blank" href="https://www.amd.com/en/corporate/xilinx-acquisition">AMD</a> |  <a target="_blank" href="https://www.amd.com/en/corporate/privacy">Learn More</a>
</div>
</div>
				<div class="parsys aem-GridColumn--xxxlarge--none aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
						<div class="container-fluid">
							<div class="row">
							<div class="col-xs-12">
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home" alt="Documentation Home"> Vitis Vision Library
          

          
          </a>

          
            
            
              <div class="version">
                2024.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

      
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
            
            
            
              
            
            
              <p class="caption"><span class="caption-text">Vitis Vision Library User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-vitis-vision">Getting Started with Vitis Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#using-the-vitis-vision-library">Using the Vitis Vision Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#getting-started-with-hls">Getting Started with HLS</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#migrating-the-hls-video-library-to-vitis-vision">Migrating the HLS Video Library to Vitis vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#design-examples-using-the-vitis-vision-library">Design Examples Using the Vitis Vision Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#id7">Defect Detection Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#isp-all-in-one-adas-pipeline">ISP all_in_one_adas Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview.html#isp-all-in-one-pipeline">ISP all_in_one Pipeline:</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision AIE Library User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#getting-started-with-vitis-vision-aie">Getting Started with Vitis Vision AIE</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#vitis-aie-design-methodology">Vitis AIE Design Methodology</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#evaluating-the-functionality">Evaluating the Functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="overview-aie.html#design-example-using-vitis-vision-aie-library">Design example Using Vitis Vision AIE Library</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#vitis-vision-library-functions">Vitis Vision Library Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#id45">Degamma</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#lens-shading-correction">Lens Shading Correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#rgbir-to-standard-bayer-format">RGBIR  to Standard Bayer Format</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#id83">Rotate</a></li>
<li class="toctree-l1"><a class="reference internal" href="api-reference.html#tvl1-optical-flow">TVL1 Optical Flow</a></li>
</ul>
<p class="caption"><span class="caption-text">Vitis Vision AIE Library API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api-reference-aie.html">Vitis Vision AIE Library API Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Benchmark</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Benchmark.html">Benchmark</a></li>
</ul>
<p class="caption"><span class="caption-text">Release Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="releasenotesxfopencv.html">Release Notes</a></li>
</ul>

            
			
			<p class="caption"><span class="caption-text">This Page</span></p>
				<ul class="current">
				  <li class="toctree-l1"><a href="_sources/design-examples.rst.txt"
						rel="nofollow">Show Source</a></li>
				</ul>
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Vitis Vision Library</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Design Examples Using the Vitis Vision Library</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/design-examples.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <span class="target" id="design-example"></span><div class="section" id="design-examples-using-the-vitis-vision-library">
<h1>Design Examples Using the Vitis Vision Library<a class="headerlink" href="#design-examples-using-the-vitis-vision-library" title="Permalink to this headline">¶</a></h1>
<p>All hardware functions in the library have their own respective
examples that are available in GitHub. This section provides details
of image processing functions and pipelines implemented using a
combination of various functions in Vitis vision. They illustrate how to
best implement various functionalities using the capabilities of both
the processor and the programmable logic (PL). These examples also illustrate
different ways to implement complex dataflow paths. The following
examples are described in this section:</p>
<ul class="simple">
<li><a class="reference external" href="#iterative-pyramidal">Iterative Pyramidal Dense Optical Flow</a></li>
<li><a class="reference external" href="#corner-tracking">Corner Tracking Using Optical Flow</a></li>
<li><a class="reference external" href="#color-detection">Color Detection</a></li>
<li><a class="reference external" href="#defect-detection-pipeline">Defect Detection</a></li>
<li><a class="reference external" href="#difference-gaussian-filter">Difference of Gaussian Filter</a></li>
<li><a class="reference external" href="#stereo-vision">Stereo Vision Pipeline</a></li>
<li><a class="reference external" href="#x-mlpipeline">Blob From Image</a></li>
<li><a class="reference external" href="#letter-box">Letterbox</a></li>
<li><a class="reference external" href="#isp">Image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#isp-201hdr">Image Sensor Processing pipeline with HDR</a></li>
<li><a class="reference external" href="#isp-201gtm">Image Sensor Processing pipeline with GTM</a></li>
<li><a class="reference external" href="#isp-201mono">Mono image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#isp_201rgbir">RGB-IR image Sensor Processing pipeline</a></li>
<li><a class="reference external" href="#isp-201multistream">Image Sensor Processing multistream pipeline</a></li>
<li><a class="reference external" href="#isp-aio-adas">Image Sensor Processing all-in-one-adas pipeline</a></li>
<li><a class="reference external" href="#isp-aio">Image Sensor Processing all-in-one pipeline</a></li>
<li><a class="reference external" href="#isp-24bit">24 bits-per-channel Image Sensor Processing pipeline</a></li>
</ul>
<div class="section" id="iterative-pyramidal">
<span id="id1"></span><h2>Iterative Pyramidal Dense Optical Flow<a class="headerlink" href="#iterative-pyramidal" title="Permalink to this headline">¶</a></h2>
<p>The Dense Pyramidal Optical Flow example uses the <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> and
<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> hardware functions from the Vitis vision
library, to create an image pyramid, iterate over it and compute the
Optical Flow between two input images. The example uses <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> function to compute the image pyramids
of the two input images. The two image pyramids are
processed by <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>
function, starting from the smallest image size going up to the largest
image size. The output flow vectors of each iteration are fed back to
the hardware kernel as input to the hardware function. The output of the
last iteration on the largest image size is treated as the output of the
dense pyramidal optical flow example.</p>
<div class="image figure" id="jcr1510602888334-image-jh4-sq2-bcb">
<img alt="" src="_images/bui1554997287170.png" />
</div>
<p>The Iterative Pyramidal Dense Optical Flow is computed in a nested for
loop which runs for iterations*pyramid levels number of iterations. The
main loop starts from the smallest image size and iterates up to the
largest image size. Before the loop iterates in one pyramid level, it
sets the current pyramid level’s height and width, in <code class="docutils literal notranslate"><span class="pre">curr_height</span></code> and
<code class="docutils literal notranslate"><span class="pre">current_width</span></code> variables. In the nested loop, the next_height variable is
set to the previous image height if scaling up is necessary, that is, in
the first iterations. As divisions are costly and one time divisions can
be avoided in hardware, the scale factor is computed in the host and
passed as an argument to the hardware kernel. After each pyramid level
in the first iteration, the scale-up flag is set to let the hardware
function know that the input flow vectors need to be scaled up to the
next higher image size. Scaling up is done using bilinear interpolation
in the hardware kernel.</p>
<p>After all the input data is prepared, and the flags are set, the host
processor calls the hardware function. Please note that the host
function swaps the flow vector inputs and outputs to the hardware
function to iteratively solve the optimization problem.</p>
</div>
<div class="section" id="corner-tracking">
<span id="id2"></span><h2>Corner Tracking Using Optical Flow<a class="headerlink" href="#corner-tracking" title="Permalink to this headline">¶</a></h2>
<p>This example illustrates how to detect and track the characteristic
feature points in a set of successive frames of video. A Harris corner
detector is used as the feature detector, and a modified version of
the Lucas Kanade optical flow is used for tracking. The core part of the
algorithm takes in current and next frame as the inputs and outputs the
list of tracked corners. The current image is the first frame in the
set, then corner detection is performed to detect the features to track.
The number of frames in which the points need to be tracked is also
provided as the input.</p>
<p>Corner tracking example uses five hardware functions from the Vitis vision
library <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::</span> <span class="pre">cornersImgToList</span></code>,
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code>, and <code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code>.</p>
<div class="image figure" id="ypx1510602888667-image-dmv-5cv-hdb">
<img alt="" src="_images/tpr1554997250097.png" />
</div>
<p>The function, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code>, has been added to ensure
that the dense flow vectors from the output of
the<code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> function are sparsely picked and stored
in a new memory location as a sparse array. This was done to ensure that
the next function in the pipeline would not have to surf through the
memory by random accesses. The function takes corners from Harris corner
detector and dense optical flow vectors from the dense pyramidal optical
flow function and outputs the updated corner locations, tracking the
input corners using the dense flow vectors, thereby imitating the sparse
optical flow behavior. This hardware function runs at 300 MHz for 10,000
corners on a 720p image, adding very minimal latency to the pipeline.</p>
<div class="section" id="cornerupdate">
<h3>cornerUpdate()<a class="headerlink" href="#cornerupdate" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span> <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornerUpdate</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">list_fix</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="nb">list</span><span class="p">,</span> <span class="n">uint32_t</span> <span class="n">nCorners</span><span class="p">,</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">flow_vectors</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">harris_flag</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id17">
<caption><span class="caption-text">Table: CornerUpdate Function Parameter Descriptions</span><a class="headerlink" href="#id17" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAXCORNE
RSNO</td>
<td>Maximum number of corners that the function needs to work
on</td>
</tr>
<tr class="row-odd"><td>TYPE</td>
<td>Input Pixel Type. Only 8-bit, unsigned, 1 channel is
supported (XF_8UC1)</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input and output image (Must be
multiple of 8)</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input and output image (Must be multiple
of 8)</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed per cycle. This function
supports only XF_NPPC1 or 1-pixel per cycle operations.</td>
</tr>
<tr class="row-odd"><td>XFCVDEPTH_IN</td>
<td>Depth of input image</td>
</tr>
<tr class="row-even"><td>list_fix</td>
<td>A list of packed fixed point coordinates of the corner
locations in 16, 5 (16 integer bits and 5 fractional
bits) format. Bits from 20 to 0 represent the column
number, while the bits 41 to 21 represent the row number.
The rest of the bits are used for flag, this flag is set
when the tracked corner is valid.</td>
</tr>
<tr class="row-odd"><td>list</td>
<td>A list of packed positive short integer coordinates of
the corner locations in unsigned short format. Bits from
15 to 0 represent the column number, while the bits 31 to
16 represent the row number. This list is same as the
list output by Harris Corner Detector.</td>
</tr>
<tr class="row-even"><td>nCorners</td>
<td>Number of corners to track</td>
</tr>
<tr class="row-odd"><td>flow_vectors</td>
<td>Packed flow vectors as in xf::cv::DensePyrOpticalFlow
function</td>
</tr>
<tr class="row-even"><td>harris_flag</td>
<td><p class="first">If set to 1, the function takes input corners from list.</p>
<p class="last">if set to 0, the function takes input corners from
list_fix.</p>
</td>
</tr>
</tbody>
</table>
<p>The example codeworks on an input video which is read and processed
using the Vitis vision library.</p>
</div>
<div class="section" id="cornersimgtolist">
<h3>cornersImgToList()<a class="headerlink" href="#cornersimgtolist" title="Permalink to this headline">¶</a></h3>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">MAXCORNERSNO</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">ROWS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">COLS</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span> <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">cornersImgToList</span><span class="p">(</span><span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span><span class="n">ROWS</span><span class="p">,</span><span class="n">COLS</span><span class="p">,</span><span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">_src</span><span class="p">,</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">list</span><span class="p">[</span><span class="n">MAXCORNERSNO</span><span class="p">],</span> <span class="n">unsigned</span> <span class="nb">int</span> <span class="o">*</span><span class="n">ncorners</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the function parameters.</p>
<table border="1" class="docutils" id="id18">
<caption><span class="caption-text">Table: CornerImgToList Function Parameter Descriptions</span><a class="headerlink" href="#id18" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="23%" />
<col width="77%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>MAXCORNERSNO</td>
<td>Maximum number of corners that the function needs to work
on</td>
</tr>
<tr class="row-odd"><td>TYPE</td>
<td>Input Pixel Type. Only 8-bit, unsigned, 1 channel is
supported (XF_8UC1)</td>
</tr>
<tr class="row-even"><td>ROWS</td>
<td>Maximum height of input and output image (Must be
multiple of 8)</td>
</tr>
<tr class="row-odd"><td>COLS</td>
<td>Maximum width of input and output image (Must be multiple
of 8)</td>
</tr>
<tr class="row-even"><td>NPC</td>
<td>Number of pixels to be processed per cycle. This function
supports only XF_NPPC1 or 1-pixel per cycle operations.</td>
</tr>
<tr class="row-odd"><td>XFCVDEPTH_IN</td>
<td>Depth of input image</td>
</tr>
<tr class="row-even"><td>_src</td>
<td>The output image of harris corner detector. The size of
this xf::cv::Mat object is the size of the input image to
Harris corner detector. The value of each pixel is 255 if
a corner is present in the location, 0 otherwise.</td>
</tr>
<tr class="row-odd"><td>list</td>
<td>A 32-bit memory allocated, the size of MAXCORNERS, to
store the corners detected by Harris Detector</td>
</tr>
<tr class="row-even"><td>ncorners</td>
<td>Total number of corners detected by Harris, that is, the
number of corners in the list</td>
</tr>
</tbody>
</table>
<div class="section" id="image-processing">
<h4>Image Processing<a class="headerlink" href="#image-processing" title="Permalink to this headline">¶</a></h4>
<p>The following steps demonstrate the Image Processing procedure in the
hardware pipeline:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> is called to start processing the first input
image.</li>
<li>The output of<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerHarris</span></code> is fed to<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code>. This function takes in an
image with corners (marked as 255 and 0 elsewhere), and converts them
to a list of corners.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::pyrDown</span></code> creates the two image pyramids and
Dense Optical Flow is computed using the two image pyramids as
described in the Iterative Pyramidal Dense Optical Flow example.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::densePyrOpticalFlow</span></code> is called with the two image pyramids as
inputs.</li>
<li><code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function is called to track the corner locations
in the second image. If <code class="docutils literal notranslate"><span class="pre">harris_flag</span></code> is enabled, the <code class="docutils literal notranslate"><span class="pre">cornerUpdate</span></code>
tracks corners from the output of the list, else it tracks the
previously tracked corners.</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">HarrisImg()</span></code> function takes a flag called
<code class="docutils literal notranslate"><span class="pre">harris_flag</span></code> which is set during the first frame or when the corners need
to be re-detected. The <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> function outputs the updated
corners to the same memory location as the output corners list of
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornerImgToList</span></code>. This means that when harris_flag is unset, the
corners input to the <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> are the corners tracked in the
previous cycle, that is, the corners in the first frame of the current
input frames.</p>
<p>After the Dense Optical Flow is computed, if <code class="docutils literal notranslate"><span class="pre">harris_flag</span></code> is set, the
number of corners that <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerharris</span></code> has detected and
<code class="docutils literal notranslate"><span class="pre">xf::cv::cornersImgToList</span></code> has updated is copied to num_corners variable
. The other being the tracked corners list, listfixed. If
harris_flag is set, <code class="docutils literal notranslate"><span class="pre">xf::cv::cornerUpdate</span></code> tracks the corners in ‘list’
memory location, otherwise it tracks the corners in ‘listfixed’ memory
location.</p>
</div>
</div>
</div>
<div class="section" id="id3">
<span id="id4"></span><h2>Color Detection<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The Color Detection algorithm is basically used for color object
tracking and object detection, based on the color of the object. The
color based methods are very useful for object detection and
segmentation, when the object and the background have a significant
difference in color.</p>
<p>The Color Detection example uses four hardware functions from the
Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::BGR2HSV</li>
<li>xf::cv::colorthresholding</li>
<li>xf::cv::erode</li>
<li>xf::cv::dilate</li>
</ul>
<p>In the Color Detection example, the color space of the original BGR
image is converted into an HSV color space. Because HSV color space is
the most suitable color space for color based image segmentation. Later,
based on the H (hue), S (saturation) and V (value) values, apply the
thresholding operation on the HSV image and return either 255 or 0.
After thresholding the image, apply erode (morphological opening) and
dilate (morphological opening) functions to reduce unnecessary white
patches (noise) in the image. Here, the example uses two hardware
instances of erode and dilate functions. The erode followed by dilate
and once again applying dilate followed by erode.</p>
<div class="image figure" id="dyn1510602889272-image-dzq-ys2-bcb">
<img alt="" src="_images/ntl1554997353703.png" />
</div>
<p>The following example demonstrates the Color Detection algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">color_detect</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">low_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">high_thresh</span><span class="p">,</span>
              <span class="n">unsigned</span> <span class="n">char</span><span class="o">*</span> <span class="n">process_shape</span><span class="p">,</span>
              <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
              <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=low_thresh    offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=low_thresh</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=high_thresh   offset=slave  bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=high_thresh</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=process_shape offset=slave  bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=process_shape</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="o">&gt;</span> <span class="n">rgb2hsv</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="o">&gt;</span> <span class="n">imgHelper1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="o">&gt;</span> <span class="n">imgHelper2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="o">&gt;</span> <span class="n">imgHelper3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="o">&gt;</span> <span class="n">imgHelper4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Copy</span> <span class="n">the</span> <span class="n">shape</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">unsigned</span> <span class="n">char</span> <span class="n">_kernel</span><span class="p">[</span><span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">unsigned</span> <span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FILTER_SIZE</span> <span class="o">*</span> <span class="n">FILTER_SIZE</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">_kernel</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">process_shape</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

    <span class="c1">#pragma HLS DATAFLOW</span>
            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
            <span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_IN_WIDTH</span><span class="p">,</span> <span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">RGBA</span> <span class="n">to</span> <span class="n">HSV</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">bgr2hsv</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">rgb2hsv</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Do</span> <span class="n">the</span> <span class="n">color</span> <span class="n">thresholding</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">colorthresholding</span><span class="o">&lt;</span><span class="n">IN_TYPE</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">MAXCOLORS</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rgb2hsv</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">rgb2hsv</span><span class="p">,</span> <span class="n">imgHelper1</span><span class="p">,</span> <span class="n">low_thresh</span><span class="p">,</span>
                                                                                                                                                                     <span class="n">high_thresh</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Use</span> <span class="n">erode</span> <span class="ow">and</span> <span class="n">dilate</span> <span class="n">to</span> <span class="n">fully</span> <span class="n">mark</span> <span class="n">color</span> <span class="n">areas</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                      <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper1</span><span class="p">,</span> <span class="n">imgHelper2</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                       <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper2</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper2</span><span class="p">,</span> <span class="n">imgHelper3</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">dilate</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                       <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper3</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper3</span><span class="p">,</span> <span class="n">imgHelper4</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">erode</span><span class="o">&lt;</span><span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">XF_KERNEL_SHAPE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">FILTER_SIZE</span><span class="p">,</span> <span class="n">ITERATIONS</span><span class="p">,</span>
                                      <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgHelper4</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgHelper4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">,</span> <span class="n">_kernel</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">_dst</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_OUT_WIDTH</span><span class="p">,</span> <span class="n">OUT_TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgOutput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>

    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the source image is passed to the <code class="docutils literal notranslate"><span class="pre">xf::cv::BGR2HSV</span></code>
function, the output of that function is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::colorthresholding</span></code> module, the thresholded image is passed to the
<code class="docutils literal notranslate"><span class="pre">xf::cv::erode</span></code> function and, the <code class="docutils literal notranslate"><span class="pre">xf::cv::dilate</span></code> functions and the final
output image are returned.</p>
<span class="target" id="defect-detection-pipeline"></span></div>
</div>
<div class="section" id="id5">
<h1>Defect Detection Pipeline<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h1>
<p>The Defect Detection accelerated application is a machine vision application that automates detection of defects in mangoes and
sorting in high-speed factory pipelines by using computer vision library functions.
The Defect detection application detects defects in a mango.</p>
<p>The Application has following pipelines:</p>
<ul class="simple">
<li>Gaussian Otsu pipeline, which includes functions <a class="reference external" href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html#custom-bgr2y8">xf::cv::custom-bgr2y8</a>,</li>
</ul>
<p><a class="reference external" href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html#gaussian-filter">xf::cv::GaussianBlur</a>, <a class="reference external" href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html#otsu-threshold">xf::cv::OtsuThreshold</a>.</p>
<ul class="simple">
<li>Preprocess pipeline, which includes functions <a class="reference external" href="https://docs.xilinx.com/r/en-US/Vitis_Libraries/vision/api-reference.html#thresholding">xf::cv::Threshold</a>, <code class="docutils literal notranslate"><span class="pre">xf::cv::fw_cca</span></code>.</li>
<li>CCA custom pipeline, which includes functions <code class="docutils literal notranslate"><span class="pre">xf::cv::rev_cca</span></code>, <code class="docutils literal notranslate"><span class="pre">xf::cv::pass_2</span></code>.</li>
</ul>
<p>In the Gaussian Otsu pipeline, the BGR input image is converted to custom y8 format and the output is processed through GaussianBlur
and OtsuThreshold which computes threshold value to mark the defects.</p>
<p>The Preprocess pipeline, which contains the <code class="docutils literal notranslate"><span class="pre">xf::cv::Threshold</span></code> function and <code class="docutils literal notranslate"><span class="pre">xf::cv::fw_cca</span></code> is moved to the preprocess pipeline to improve performance
where it processes the image in forward direction to get information on edge between mango pixels and background pixels.</p>
<p>The CCA custom pipeline, which includes <code class="docutils literal notranslate"><span class="pre">xf::cv::rev_cca</span></code>, which processes the image in a backwards direction and <code class="docutils literal notranslate"><span class="pre">xf::cv::pass_2</span></code> which adds
both forward and backward passes and gives the number of defect pixels.</p>
<p><img alt="image1" class="image" src="_images/defect_detection_pp.png" /></p>
<p><img alt="image2" class="image" src="_images/cca_kernel.png" /></p>
<div class="section" id="pass-2">
<h2>pass_2()<a class="headerlink" href="#pass-2" title="Permalink to this headline">¶</a></h2>
<p class="rubric">API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">SRC_T</span><span class="p">,</span> <span class="nb">int</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="nb">int</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span> <span class="nb">int</span> <span class="n">XFCVDEPTH_OUT</span><span class="o">&gt;</span>
<span class="n">void</span> <span class="n">pass_2</span><span class="p">(</span><span class="n">uint8_t</span><span class="o">*</span> <span class="n">fwd_in_ptr</span><span class="p">,</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">SRC_T</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_OUT</span><span class="o">&gt;&amp;</span> <span class="n">tmp_out_mat</span><span class="p">,</span>
            <span class="n">uint8_t</span><span class="o">*</span> <span class="n">out_ptr</span><span class="p">,</span>
            <span class="nb">int</span><span class="o">&amp;</span> <span class="n">def_pix</span><span class="p">,</span>
            <span class="nb">int</span> <span class="n">height</span><span class="p">,</span>
            <span class="nb">int</span> <span class="n">width</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Parameter Descriptions</p>
<p>The following table describes the template and the function parameters.</p>
<table border="1" class="docutils" id="id19">
<caption><span class="caption-text">Table: Pass_2 Parameter Description</span><a class="headerlink" href="#id19" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SRC_T</td>
<td>Input Pixel type. The current supported pixel value is
XF_8UC1</td>
</tr>
<tr class="row-odd"><td>HEIGHT</td>
<td>Maximum height of the image that hardware kernel must be
built for</td>
</tr>
<tr class="row-even"><td>WIDTH</td>
<td>Maximum width of the image that hardware kernel must be
built for</td>
</tr>
<tr class="row-odd"><td>NPC</td>
<td>Number of Pixels to be processed per cycle. NPPC1 is
supported.</td>
</tr>
<tr class="row-even"><td>XFCVDEPTH_OUT</td>
<td>Depth of Mat Image</td>
</tr>
<tr class="row-odd"><td>fwd_in_ptr</td>
<td>Output Image pointer of fw_cca</td>
</tr>
<tr class="row-even"><td>tmp_out_mat</td>
<td>Output Image of rev_cca</td>
</tr>
<tr class="row-odd"><td>out_ptr</td>
<td>Output Image pointer of pass_2</td>
</tr>
<tr class="row-even"><td>def_pix</td>
<td>number of defect pixels</td>
</tr>
<tr class="row-odd"><td>height</td>
<td>height of Image pointer</td>
</tr>
<tr class="row-even"><td>width</td>
<td>width of Image pointer</td>
</tr>
</tbody>
</table>
<p class="rubric">Resource Utilization</p>
<p>The following table summarizes the resource utilization in different configurations, generated using Vitis HLS 2022.2 tool for the xcu200-fsgd2104-2-e, to process a FHD image.</p>
<table border="1" class="docutils" id="id20">
<caption><span class="caption-text">Table: Defect detection Resource Utilization Summary at 300MHz Frequency and 1 Pixel per clock cycle</span><a class="headerlink" href="#id20" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="30%" />
<col width="26%" />
<col width="14%" />
<col width="10%" />
<col width="10%" />
<col width="9%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Pipelines</th>
<th class="head" colspan="5">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">BRAM_18K</th>
<th class="head">DSP</th>
<th class="head">FF</th>
<th class="head">LUT</th>
<th class="head">URAM</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>Gaussian_Otsu</td>
<td>12</td>
<td>71</td>
<td>11703</td>
<td>13633</td>
<td>0</td>
</tr>
<tr class="row-even"><td>Preprocess</td>
<td>7</td>
<td>9</td>
<td>4123</td>
<td>5244</td>
<td>0</td>
</tr>
<tr class="row-odd"><td>Custom CCA</td>
<td>10</td>
<td>10</td>
<td>12642</td>
<td>13756</td>
<td>0</td>
</tr>
</tbody>
</table>
<p class="rubric">Performance Estimate</p>
<p>The following table summarizes the performance estimates in different configurations, generated using Vitis HLS 2022.2 tool for the xcu200-fsgd2104-2-e, to process a FHD image.</p>
<table border="1" class="docutils" id="id21">
<caption><span class="caption-text">Table: GTM Performance Estimate Summary</span><a class="headerlink" href="#id21" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="38%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Pipelines</th>
<th class="head" rowspan="2"><p class="first">Operating Frequency</p>
<p class="last">(MHz)</p>
</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Max (ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>Gaussian_Otsu</td>
<td>300</td>
<td>7.1</td>
</tr>
<tr class="row-even"><td>Preprocess</td>
<td>300</td>
<td>14.4</td>
</tr>
<tr class="row-odd"><td>Custom CCA</td>
<td>300</td>
<td>7</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="difference-gaussian-filter">
<span id="id6"></span><h2>Difference of Gaussian Filter<a class="headerlink" href="#difference-gaussian-filter" title="Permalink to this headline">¶</a></h2>
<p>The Difference of Gaussian Filter example uses four hardware functions
from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::GaussianBlur</li>
<li>xf::cv::duplicateMat</li>
<li>xf::cv::subtract</li>
</ul>
<p>The Difference of Gaussian Filter function can be implemented by
applying Gaussian Filter on the original source image, and that Gaussian
blurred image is duplicated as two images. The Gaussian blur function is
applied to one of the duplicated images, whereas the other one is stored
as it is. Later, perform the Subtraction function on, two times Gaussian
applied image and one of the duplicated image.</p>
<div class="image figure" id="fmq1510602889620-image-lgr-1xf-bcb">
<img alt="" src="_images/crx1554997276344.png" />
</div>
<p>The following example demonstrates the Difference of Gaussian Filter
example.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">gaussiandiference</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_in</span><span class="p">,</span> <span class="nb">float</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi      port=img_in        offset=slave  bundle=gmem0</span>
<span class="c1">#pragma HLS INTERFACE m_axi      port=img_out       offset=slave  bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=sigma</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=rows</span>
    <span class="c1">#pragma HLS INTERFACE s_axilite  port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite  port=return</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgInput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin1</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin2</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span> <span class="n">imgin3</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgin4</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span> <span class="n">imgOutput</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

            <span class="o">//</span> <span class="n">Retrieve</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="n">objects</span> <span class="kn">from</span> <span class="nn">img_in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_in</span><span class="p">,</span> <span class="n">imgInput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Run</span> <span class="n">xfOpenCV</span> <span class="n">kernel</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgInput</span><span class="p">,</span> <span class="n">imgin1</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">duplicateMat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin1</span><span class="p">,</span> <span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin3</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">GaussianBlur</span><span class="o">&lt;</span><span class="n">FILTER_WIDTH</span><span class="p">,</span> <span class="n">XF_BORDER_CONSTANT</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin2</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">sigma</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">subtract</span><span class="o">&lt;</span><span class="n">XF_CONVERT_POLICY_SATURATE</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="p">,</span> <span class="mi">15360</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgin3</span><span class="p">,</span> <span class="n">imgin4</span><span class="p">,</span> <span class="n">imgOutput</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">Convert</span> <span class="n">output</span> <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="nb">object</span> <span class="n">to</span> <span class="n">output</span> <span class="n">array</span><span class="p">:</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">imgOutput</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>

            <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="o">//</span> <span class="n">End</span> <span class="n">of</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>In the given example, the Gaussain Blur function is applied for source
image imginput, and resultant image imgin1 is passed to
xf::cv::duplicateMat. The imgin2 and imgin3 are the duplicate images of
Gaussian applied image. Again gaussian blur is applied to imgin2 and the
result is stored in imgin4. Now, perform the subtraction between imgin4
and imgin3, but here imgin3 has to wait up to at least one pixel of
imgin4 generation. Finally the subtraction performed on imgin3 and imgin4.</p>
</div>
<div class="section" id="stereo-vision">
<span id="id7"></span><h2>Stereo Vision Pipeline<a class="headerlink" href="#stereo-vision" title="Permalink to this headline">¶</a></h2>
<p>Disparity map generation is one of the first steps in creating a three
dimensional map of the environment. The Vitis vision library has components
to build an image processing pipeline to compute a disparity map given
the camera parameters and inputs from a stereo camera setup.</p>
<p>The two main components involved in the pipeline are stereo
rectification and disparity estimation using local block matching
method. While disparity estimation using local block matching is a
discrete component in Vitis vision, rectification block can be constructed
using <code class="docutils literal notranslate"><span class="pre">xf::cv::InitUndistortRectifyMapInverse()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::Remap()</span></code>. The
dataflow pipeline is shown below. The camera parameters are an
additional input to the pipeline.</p>
<div class="image figure">
<a class="reference internal image-reference" href="_images/qlb1554997048260.png"><img alt="" src="_images/qlb1554997048260.png" style="width: 560px; height: 240px;" /></a>
</div>
<p>The following code is for the pipeline.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">stereopipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_L</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_R</span><span class="p">,</span>
                      <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_disp</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">cameraMA_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">distC_r</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_l</span><span class="p">,</span>
                      <span class="nb">float</span><span class="o">*</span> <span class="n">irA_r</span><span class="p">,</span>
                      <span class="nb">int</span><span class="o">*</span> <span class="n">bm_state_arr</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">rows</span><span class="p">,</span>
                      <span class="nb">int</span> <span class="n">cols</span><span class="p">)</span> <span class="p">{</span>

<span class="c1">#pragma HLS INTERFACE m_axi     port=img_L  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_R  offset=slave bundle=gmem5</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_disp  offset=slave bundle=gmem6</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=cameraMA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_l  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=distC_r  offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_l  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=irA_r  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=bm_state_arr  offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>

            <span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span> <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span> <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
                    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">XF_DIST_COEFF_SIZE</span><span class="p">],</span> <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">],</span>
                    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">];</span>

            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE II=1</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">cameraMA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">cameraMA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">cameraMA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">irA_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">irA_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">irA_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS PIPELINE II=1</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
                    <span class="n">distC_l_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_l</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">distC_r_fix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">ap_fixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">12</span><span class="o">&gt;</span><span class="p">)</span><span class="n">distC_r</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="p">}</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xFSBMState</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="o">&gt;</span> <span class="n">bm_state</span><span class="p">;</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterType</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">preFilterCap</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">SADWindowSize</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">minDisparity</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">numberOfDisparities</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">textureThreshold</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">uniquenessRatio</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">7</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">ndisp_unit</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">sweepFactor</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
            <span class="n">bm_state</span><span class="o">.</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">bm_state_arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

            <span class="nb">int</span> <span class="n">_cm_size</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">_dc_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="o">&gt;</span> <span class="n">mat_L</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="o">&gt;</span> <span class="n">mat_R</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span> <span class="n">mat_disp</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="o">&gt;</span> <span class="n">mapxLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span> <span class="n">mapyLMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="o">&gt;</span> <span class="n">mapxRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span> <span class="n">mapyRMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="o">&gt;</span> <span class="n">leftRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="o">&gt;</span> <span class="n">rightRemappedMat</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">);</span>


    <span class="c1">#pragma HLS DATAFLOW</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_L</span><span class="p">,</span> <span class="n">mat_L</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_R</span><span class="p">,</span> <span class="n">mat_R</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                                                                       <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_l_fix</span><span class="p">,</span> <span class="n">distC_l_fix</span><span class="p">,</span> <span class="n">irA_l_fix</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">,</span>
                                                                                                             <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                      <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_L</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XL</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YL</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_L</span><span class="p">,</span> <span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">mapxLMat</span><span class="p">,</span> <span class="n">mapyLMat</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">InitUndistortRectifyMapInverse</span><span class="o">&lt;</span><span class="n">XF_CAMERA_MATRIX_SIZE</span><span class="p">,</span> <span class="n">XF_DIST_COEFF_SIZE</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                                                                       <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cameraMA_r_fix</span><span class="p">,</span> <span class="n">distC_r_fix</span><span class="p">,</span> <span class="n">irA_r_fix</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">,</span>
                                                                                                             <span class="n">_cm_size</span><span class="p">,</span> <span class="n">_dc_size</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">remap</span><span class="o">&lt;</span><span class="n">XF_REMAP_BUFSIZE</span><span class="p">,</span> <span class="n">XF_INTERPOLATION_BILINEAR</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_32FC1</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                      <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_R</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_XR</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAP_YR</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_R</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mapxRMat</span><span class="p">,</span> <span class="n">mapyRMat</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">StereoBM</span><span class="o">&lt;</span><span class="n">SAD_WINDOW_SIZE</span><span class="p">,</span> <span class="n">NO_OF_DISPARITIES</span><span class="p">,</span> <span class="n">PARALLEL_UNITS</span><span class="p">,</span> <span class="n">XF_8UC1</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                             <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_LEFT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_RIGHT_REMAPPED</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">leftRemappedMat</span><span class="p">,</span> <span class="n">rightRemappedMat</span><span class="p">,</span> <span class="n">mat_disp</span><span class="p">,</span> <span class="n">bm_state</span><span class="p">);</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_16UC1</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_MAT_DISP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mat_disp</span><span class="p">,</span> <span class="n">img_disp</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="x-mlpipeline">
<span id="id8"></span><h2>Blob From Image<a class="headerlink" href="#x-mlpipeline" title="Permalink to this headline">¶</a></h2>
<p>This example shows how various xfOpenCV funtions can be used to accelerate preprocessing of input images before feeding them to a Deep Neural Network (DNN) accelerator.</p>
<p>This specific application shows how pre-processing for Googlenet_v1 can be accelerated which involves resizing the input image to 224 x 224 size followed by mean subtraction. The two main
functions from Vitis vision library which are used to build this pipeline are <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> which operate in dataflow.</p>
<p><a class="image reference internal" href="_images/gnet_pp.png"><img alt="pp_image" class="image" src="_images/gnet_pp.png" style="width: 500px;" /></a></p>
<p>The following code shows the top level wrapper containing the <code class="docutils literal notranslate"><span class="pre">xf::cv::resize()</span></code> and <code class="docutils literal notranslate"><span class="pre">xf::cv::preProcess()</span></code> calls.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">pp_pipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">img_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span> <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span> <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span> <span class="nb">float</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="o">*</span><span class="n">T_CHANNELS</span><span class="p">],</span> <span class="nb">int</span> <span class="n">th1</span><span class="p">,</span> <span class="nb">int</span> <span class="n">th2</span><span class="p">)</span>
<span class="p">{</span>
<span class="o">//</span><span class="n">HLS</span> <span class="n">Interface</span> <span class="n">pragmas</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=params  offset=slave bundle=gmem3</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th1     bundle=control</span>
<span class="c1">#pragma HLS INTERFACE s_axilite port=th2     bundle=control</span>

<span class="c1">#pragma HLS INTERFACE s_axilite port=return   bundle=control</span>

            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_8UC3</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>   <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>
            <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>

    <span class="n">hls</span><span class="p">::</span><span class="n">stream</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">256</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">resizeStrmout</span><span class="p">;</span>
    <span class="nb">int</span> <span class="n">srcMat_cols_align_npc</span> <span class="o">=</span> <span class="p">((</span><span class="n">out_mat</span><span class="o">.</span><span class="n">cols</span> <span class="o">+</span> <span class="p">(</span><span class="n">NPC_T</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">NPC_T</span><span class="p">);</span>

    <span class="c1">#pragma HLS DATAFLOW</span>

    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC1</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span><span class="n">XF_USE_URAM</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">accel_utils</span> <span class="n">obj</span><span class="p">;</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">xfMat2hlsStrm</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="p">(</span><span class="n">NEWWIDTH</span><span class="o">*</span><span class="n">NEWHEIGHT</span><span class="o">/</span><span class="mi">8</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">srcMat_cols_align_npc</span><span class="p">);</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">preProcess</span> <span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">T_CHANNELS</span><span class="p">,</span> <span class="n">CPW</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_TEST</span><span class="p">,</span> <span class="n">PACK_MODE</span><span class="p">,</span> <span class="n">X_WIDTH</span><span class="p">,</span> <span class="n">ALPHA_WIDTH</span><span class="p">,</span> <span class="n">BETA_WIDTH</span><span class="p">,</span> <span class="n">GAMMA_WIDTH</span><span class="p">,</span> <span class="n">OUT_WIDTH</span><span class="p">,</span> <span class="n">X_IBITS</span><span class="p">,</span> <span class="n">ALPHA_IBITS</span><span class="p">,</span> <span class="n">BETA_IBITS</span><span class="p">,</span> <span class="n">GAMMA_IBITS</span><span class="p">,</span> <span class="n">OUT_IBITS</span><span class="p">,</span> <span class="n">SIGNED_IN</span><span class="p">,</span> <span class="n">OPMODE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">resizeStrmout</span><span class="p">,</span> <span class="n">img_out</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">,</span> <span class="n">th1</span><span class="p">,</span> <span class="n">th2</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>
</div>
<p>This piepeline is integrated with Deep learning Processign Unit (DPU) as part of <a class="reference external" href="https://github.com/Xilinx/Vitis-AI">Vitis-AI-Library</a>  and achieved
11 % speed up compared to software pre-procesing.</p>
<ul class="simple">
<li>Overall Performance (Images/sec):<ul>
<li>with software pre-processing : 125 images/sec</li>
<li>with hardware accelerated pre-processing : 140 images/sec</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="letter-box">
<span id="id9"></span><h2>Letterbox<a class="headerlink" href="#letter-box" title="Permalink to this headline">¶</a></h2>
<p>The Letterbox algorithm is used for scaling input image to desired output size while preserving aspect ratio of original image. If required, zeroes are padded for preserving the aspect ratio post resize.</p>
<p>An application of letterbox is in the pre-processing block of machine learning pipelines used in image processing.</p>
<p><a class="image reference internal" href="_images/letterbox.PNG"><img alt="pp_image1" class="image" src="_images/letterbox.PNG" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the Letterbox algorithm.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">void</span> <span class="n">letterbox_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_in</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">rows_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">cols_out</span><span class="p">,</span>
                    <span class="nb">int</span> <span class="n">insert_pad_value</span><span class="p">)</span> <span class="p">{</span>

            <span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1</span>
            <span class="c1">#pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_in</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_in</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=rows_out</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=cols_out</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=insert_pad_value</span>
            <span class="c1">#pragma HLS INTERFACE s_axilite port=return</span>


                    <span class="o">//</span> <span class="n">Compute</span> <span class="n">Resize</span> <span class="n">output</span> <span class="n">image</span> <span class="n">size</span> <span class="k">for</span> <span class="n">Letterbox</span>
                    <span class="nb">float</span> <span class="n">scale_height</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">scale_width</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_out</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">;</span>
                    <span class="nb">int</span> <span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">;</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">scale_width</span><span class="o">&lt;</span><span class="n">scale_height</span><span class="p">){</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="n">cols_out</span><span class="p">;</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">rows_in</span><span class="o">*</span><span class="n">cols_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">cols_in</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">else</span><span class="p">{</span>
                            <span class="n">cols_out_resize</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)((</span><span class="nb">float</span><span class="p">)(</span><span class="n">cols_in</span><span class="o">*</span><span class="n">rows_out</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">rows_in</span><span class="p">);</span>
                            <span class="n">rows_out_resize</span> <span class="o">=</span> <span class="n">rows_out</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span> <span class="n">imgInput0</span><span class="p">(</span><span class="n">rows_in</span><span class="p">,</span> <span class="n">cols_in</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="o">&gt;</span> <span class="n">out_mat_resize</span><span class="p">(</span><span class="n">rows_out_resize</span><span class="p">,</span> <span class="n">cols_out_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span> <span class="n">out_mat</span><span class="p">(</span><span class="n">rows_out</span><span class="p">,</span> <span class="n">cols_out</span><span class="p">);</span>

            <span class="c1">#pragma HLS DATAFLOW</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span><span class="n">XF_8UC3</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span> <span class="n">WIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="o">&gt;</span>  <span class="p">(</span><span class="n">img_inp</span><span class="p">,</span> <span class="n">imgInput0</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">resize</span><span class="o">&lt;</span><span class="n">INTERPOLATION</span><span class="p">,</span><span class="n">TYPE</span><span class="p">,</span><span class="n">HEIGHT</span><span class="p">,</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">NEWHEIGHT</span><span class="p">,</span><span class="n">NEWWIDTH</span><span class="p">,</span><span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_USE_URAM</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_IN_0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="p">,</span><span class="n">MAXDOWNSCALE</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">imgInput0</span><span class="p">,</span> <span class="n">out_mat_resize</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">insertBorder</span><span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat_resize</span><span class="p">,</span> <span class="n">out_mat</span><span class="p">,</span> <span class="n">insert_pad_value</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">xfMat2Array</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">TYPE</span><span class="p">,</span> <span class="n">NEWHEIGHT</span><span class="p">,</span> <span class="n">NEWWIDTH</span><span class="p">,</span> <span class="n">NPC_T</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_OUT_2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out_mat</span><span class="p">,</span> <span class="n">img_out</span><span class="p">);</span>
                    <span class="k">return</span><span class="p">;</span>
                    <span class="p">}</span><span class="o">//</span> <span class="n">end</span> <span class="n">kernel</span>
</pre></div>
</div>
<p>The Letterbox example uses two hardware functions from the Vitis vision library. They are:</p>
<ul class="simple">
<li>xf::cv::resize</li>
<li>xf::cv::insertBorder</li>
</ul>
<p>In the given example, the source image is passed to the xf::cv::resize function.
The output of that function is passed to the xf::cv::insertBorder module and the final output image are returned.</p>
<p class="rubric">Insert Border API Syntax</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">template</span> <span class="o">&lt;</span>
    <span class="nb">int</span> <span class="n">TYPE</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">SRC_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_ROWS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">DST_COLS</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">NPC</span><span class="p">,</span>
        <span class="nb">int</span> <span class="n">XFCVDEPTH_IN</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span><span class="p">,</span>
<span class="nb">int</span> <span class="n">XFCVDEPTH_OUT</span> <span class="o">=</span> <span class="n">_XFCVDEPTH_DEFAULT</span>
    <span class="o">&gt;</span>
<span class="n">void</span> <span class="n">insertBorder</span> <span class="p">(</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">SRC_ROWS</span><span class="p">,</span> <span class="n">SRC_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_IN</span><span class="o">&gt;&amp;</span> <span class="n">_src</span><span class="p">,</span>
    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span> <span class="o">&lt;</span><span class="n">TYPE</span><span class="p">,</span> <span class="n">DST_ROWS</span><span class="p">,</span> <span class="n">DST_COLS</span><span class="p">,</span> <span class="n">NPC</span><span class="p">,</span> <span class="n">XFCVDEPTH_OUT</span><span class="o">&gt;&amp;</span> <span class="n">_dst</span><span class="p">,</span>
    <span class="nb">int</span> <span class="n">insert_pad_val</span>
    <span class="p">)</span>


<span class="p">:</span><span class="n">start</span><span class="o">-</span><span class="n">after</span><span class="p">:</span>    <span class="s2">&quot;dnn/xf_insertBorder.hpp&quot;</span>
</pre></div>
</div>
</div>
<div class="section" id="isp">
<span id="id10"></span><h2>Image Sensor Processing pipeline<a class="headerlink" href="#isp" title="Permalink to this headline">¶</a></h2>
<p>Image Sensor Processing (ISP) is a pipeline of image processing functions processing the raw image from the sensor.</p>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction: Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction): An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control: The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing: The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Colorcorrection matrix: corrects color suitable for display or video system.</li>
<li>Quantization and Dithering: Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction: Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion: Converting RGB image to YUV422(YUYV) image for HDMI display purpose. RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-2021_1.PNG"><img alt="isp-20211" class="image" src="_images/isp-2021_1.PNG" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>User can dynamically configure the below parameters to the pipeline.</p>
<table border="1" class="docutils" id="id22">
<caption><span class="caption-text">Runtime parameters for the pipeline</span><a class="headerlink" href="#id22" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
</tbody>
</table>
<p>User can also use below compile time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id23">
<caption><span class="caption-text">Compiletime parameters for the pipeline</span><a class="headerlink" href="#id23" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be a multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
supported formats are RGGB,BGGR,GBRG,GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>         void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                         ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                         int height,
                         int width,
                         uint16_t rgain,
                         uint16_t bgain,
                         unsigned char gamma_lut[256 * 3],
                         unsigned char mode_reg,
                         uint16_t pawb) {

         #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
         #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2

         #pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
         #pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                         if (!flag) {
                                 ISPpipeline(img_inp, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain, gamma_lut,
                                                         mode_reg, pawb);
                                 flag = 1;

                         } else {
                                 ISPpipeline(img_inp, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain, gamma_lut,
                                                         mode_reg, pawb);
                                 flag = 0;
                         }
                         }

         void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                 unsigned short height,
                                 unsigned short width,
                                 uint32_t hist0[3][HIST_SIZE],
                                 uint32_t hist1[3][HIST_SIZE],
                                 int gain0[3],
                                 int gain1[3],
                                 uint16_t rgain,
                                 uint16_t bgain,
                                 unsigned char gamma_lut[256 * 3],
                                 unsigned char mode_reg,
                                 uint16_t pawb) {

                 #pragma HLS INLINE OFF

                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt; imgInput1(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput2(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; bpc_out(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_3&gt; gain_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0&gt; demosaic_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_1&gt; impop(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2&gt; ltm_in(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3&gt; lsc_out(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4&gt; _dst(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5&gt; aecin(height, width);
                         xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt; _imgOutput(height, width);


                 #pragma HLS DATAFLOW

                         const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
                         float thresh = (float)pawb / 256;
                         float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                         float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
unsigned int blc_config_1 = (int)(mul_fact * 65536); // mul_fact int Q16_16 format
unsigned int blc_config_2 = BLACK_LEVEL;

                         xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt;(img_inp, imgInput1);
                         xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_0, XF_CV_DEPTH_IN_1&gt;(imgInput1, imgInput2, blc_config_2,blc_config_1);
                         xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_3&gt;(imgInput2, gain_out, rgain, bgain);
                         xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_IN_3, XF_CV_DEPTH_OUT_0&gt;(gain_out, demosaic_out);
                         function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0, XF_CV_DEPTH_OUT_2&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
                         xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2, XF_CV_DEPTH_OUT_3&gt;(ltm_in, lsc_out);
                         if (XF_DST_T == XF_8UC3) {
                                 fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin, height, width);
                         } else {
                                 xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin);
                         }
                         xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5, XF_CV_DEPTH_OUT_4&gt;(aecin, _dst, gamma_lut);
                         xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4, XF_CV_DEPTH_OUT_6&gt;(_dst, _imgOutput);
                         xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt;(_imgOutput, img_out);
                 }
</pre></div>
</div>
</div>
<div class="section" id="isp-201hdr">
<span id="id11"></span><h2>Image Sensor Processing Pipeline with HDR<a class="headerlink" href="#isp-201hdr" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes HDR function with 2021.1 pipeline without color space conversion. It takes two exposure frames as inputs (a short exposure frame and a long exposure frame) and
after HDR fusion it will return an HDR merged output frame. The HDR output goes to the ISP 2021.1 pipeline and returns the output RGB image.</p>
<ul class="simple">
<li>HDRMerge: The HDRMerge module generates the HDR image from a set of different exposure frames. Usually, image sensors have limited dynamic range and it is difficult to get an HDR image with a single image capture. From the sensor, the frames are collected with different exposure times and will get different exposure frames, HDRMerge will generates the HDR frame with those exposure frames.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-hdr.PNG"><img alt="isp-hdr" class="image" src="_images/isp-hdr.PNG" style="width: 1000px;" /></a></p>
<p>The following example demonstrates the ISP pipeline with HDR.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>                 void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp1,
                         ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp2,
                         ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                         int height,
                         int width,
                         uint16_t rgain,
                         uint16_t bgain,
                         unsigned char gamma_lut[256 * 3],
                         unsigned char mode_reg,
                         uint16_t pawb,
                         short* wr_hls) {

                 #pragma HLS INTERFACE m_axi     port=img_inp1  offset=slave bundle=gmem1
                 #pragma HLS INTERFACE m_axi     port=img_inp2  offset=slave bundle=gmem2
                 #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem3
                 #pragma HLS INTERFACE m_axi     port=wr_hls  offset=slave bundle=gmem4

                 #pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
                 #pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                         if (!flag) {
                                 ISPpipeline(img_inp1, img_inp2, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain,
                                                         gamma_lut, mode_reg, pawb, wr_hls);
                                 flag = 1;

                         } else {
                                 ISPpipeline(img_inp1, img_inp2, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain,
                                                         gamma_lut, mode_reg, pawb, wr_hls);
                                 flag = 0;
                         }
                 }

                 void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp1,
                                         ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp2,
                                         ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                         unsigned short height,
                                         unsigned short width,
                                         uint32_t hist0[3][HIST_SIZE],
                                         uint32_t hist1[3][HIST_SIZE],
                                         int gain0[3],
                                         int gain1[3],
                                         uint16_t rgain,
                                         uint16_t bgain,
                                         unsigned char gamma_lut[256 * 3],
                                         unsigned char mode_reg,
                                         uint16_t pawb,
                                         short* wr_hls) {

                 #pragma HLS INLINE OFF

                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1&gt; imgInputhdr1(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR2&gt; imgInputhdr2(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput1(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; imgInput2(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_BPC_OUT&gt; bpc_out(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT&gt; gain_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DEMOSAIC_OUT&gt; demosaic_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IMPOP&gt; impop(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LTM_IN&gt; ltm_in(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LSC_OUT&gt; lsc_out(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt; _dst(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN&gt; aecin(height, width);
                         xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt; _imgOutput(height, width);


                 #pragma HLS DATAFLOW

                         const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
                         float thresh = (float)pawb / 256;
                         float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                         float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
unsigned int blc_config_1 = (int)(mul_fact * 65536); // mul_fact int Q16_16 format
unsigned int blc_config_2 = BLACK_LEVEL;
                         xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1&gt;(img_inp1, imgInputhdr1);
                         xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR2&gt;(img_inp2, imgInputhdr2);

                         xf::cv::Hdrmerge_bayer&lt;XF_SRC_T, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_DR1, XF_CV_DEPTH_IN_DR2, NO_EXPS, W_B_SIZE&gt;(
                                 imgInputhdr1, imgInputhdr2, imgInput1, wr_hls);

                         xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_2&gt;(imgInput1, imgInput2, blc_config_2,blc_config_1);
                         xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2, XF_CV_DEPTH_GAIN_OUT&gt;(imgInput2, gain_out, rgain, bgain);
                         xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_GAIN_OUT,XF_CV_DEPTH_DEMOSAIC_OUT&gt;(gain_out, demosaic_out);
                         function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DEMOSAIC_OUT, XF_CV_DEPTH_LTM_IN&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
                         xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LTM_IN, XF_CV_DEPTH_LSC_OUT&gt;(ltm_in, lsc_out);
                         if (XF_DST_T == XF_8UC3) {
                                 fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_LSC_OUT, XF_CV_DEPTH_AEC_IN&gt;(lsc_out, aecin, height, width);
                         } else {
                                 xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_LSC_OUT, XF_CV_DEPTH_AEC_IN&gt;(lsc_out, aecin);
                         }
                         xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN, XF_CV_DEPTH_DST&gt;(aecin, _dst, gamma_lut);
                         xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_8UC3, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt;(_dst, img_out);
                 }
</pre></div>
</div>
</div>
<div class="section" id="isp-201gtm">
<span id="id12"></span><h2>Image Sensor Processing pipeline with GTM<a class="headerlink" href="#isp-201gtm" title="Permalink to this headline">¶</a></h2>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction: Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction): An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. The Bad pixel correction module removes defective pixels.</li>
<li>Gain Control: The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing: The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Colorcorrection matrix: corrects color suitable for display or video system.</li>
<li>Global tone mapping: Reduces the dynamic range from higher range to display range using tone mapping.</li>
<li>Gamma correction: Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion : Converting RGB image to YUV422(YUYV) image for HDMI display purpose.RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-gtm.png"><img alt="isp-gtm" class="image" src="_images/isp-gtm.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>You can dynamically configure the following parameters to the pipeline.</p>
<table border="1" class="docutils" id="id24">
<caption><span class="caption-text">Runtime Parameters for the Pipeline</span><a class="headerlink" href="#id24" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-odd"><td>c1</td>
<td>To retain the details in bright area using, c1 in the
tone mapping.</td>
</tr>
<tr class="row-even"><td>c2</td>
<td>Efficiency factor, ranges from 0.5 to 1 based on
output device dynamic range.</td>
</tr>
</tbody>
</table>
<p>You can also use the following compile-time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id25">
<caption><span class="caption-text">Compile-Time Parameters for the Pipeline</span><a class="headerlink" href="#id25" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be a multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
supported formats are RGGB,BGGR,GBRG,GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with the above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>         void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                         ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                         int height,
                         int width,
                         uint16_t rgain,
                         uint16_t bgain,
                         unsigned char gamma_lut[256 * 3],
                         unsigned char mode_reg,
                         uint16_t pawb,
     float c1,
     float c2) {

         #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
         #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2

         #pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
         #pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                         if (!flag) {
                                   ISPpipeline(img_inp, img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain, gamma_lut,
                                                           mode_reg, pawb, mean2, mean1, L_max2, L_max1, L_min2, L_min1, c1, c2);
                                   flag = 1;

                         } else {
                                   ISPpipeline(img_inp, img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain, gamma_lut,
                                                           mode_reg, pawb, mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2);
                                   flag = 0;
                         }
                         }

         void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                 ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                 unsigned short height,
                                 unsigned short width,
                                 uint32_t hist0[3][HIST_SIZE],
                                 uint32_t hist1[3][HIST_SIZE],
                                 int gain0[3],
                                 int gain1[3],
                                 uint16_t rgain,
                                 uint16_t bgain,
                                 unsigned char gamma_lut[256 * 3],
                                 unsigned char mode_reg,
                                 uint16_t pawb,
         ap_ufixed&lt;16, 4&gt;&amp; mean1,
         ap_ufixed&lt;16, 4&gt;&amp; mean2,
         ap_ufixed&lt;16, 4&gt;&amp; L_max1,
         ap_ufixed&lt;16, 4&gt;&amp; L_max2,
         ap_ufixed&lt;16, 4&gt;&amp; L_min1,
         ap_ufixed&lt;16, 4&gt;&amp; L_min2,
         float c1,
         float c2) {

                 #pragma HLS INLINE OFF

                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt; imgInput1(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput2(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; bpc_out(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_3&gt; gain_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0&gt; demosaic_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_1&gt; impop(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2&gt; ltm_in(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3&gt; lsc_out(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4&gt; _dst(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5&gt; aecin(height, width);
                         xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt; _imgOutput(height, width);


                 #pragma HLS DATAFLOW

                         const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));
                         float thresh = (float)pawb / 256;
                         float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;
                         float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
unsigned int blc_config_1 = (int)(mul_fact * 65536); // mul_fact int Q16_16 format
unsigned int blc_config_2 = BLACK_LEVEL;

                         xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_0&gt;(img_inp, imgInput1);
                         xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_0, XF_CV_DEPTH_IN_1&gt;(imgInput1, imgInput2, blc_config_2,blc_config_1);
                         xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPCC, XF_CV_DEPTH_IN_1,&gt;(imgInput2, gain_out, rgain, bgain);
                         xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_IN_3, XF_CV_DEPTH_OUT_0&gt;(gain_out, demosaic_out);
                         function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_0, XF_CV_DEPTH_OUT_2&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1,height, width, mode_reg, thresh);
                         xf::cv::colorcorrectionmatrix&lt;XF_CCM_TYPE, XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_2, XF_CV_DEPTH_OUT_3&gt;(ltm_in, lsc_out);

                         if (XF_DST_T == XF_8UC3) {
                                 fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(lsc_out, aecin, height, width);
                         } else {
                                  xf::cv::gtm&lt;XF_DST_T, XF_LTM_T, XF_SRC_T, SIN_CHANNEL_TYPE, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_3, XF_CV_DEPTH_OUT_5&gt;(
          lsc_out, aecin, mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2, height, width);
                         }
                         xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_5, XF_CV_DEPTH_OUT_4&gt;(aecin, _dst, gamma_lut);
                         xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_4, XF_CV_DEPTH_OUT_6&gt;(_dst, _imgOutput);
                         xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT_6&gt;(_imgOutput, img_out);
                 }
</pre></div>
</div>
</div>
<div class="section" id="isp-201mono">
<span id="id13"></span><h2>Mono Image Sensor Processing pipeline<a class="headerlink" href="#isp-201mono" title="Permalink to this headline">¶</a></h2>
<p>The Mono image sensor is different to the RGB Bayer sensor. Some applications do not need color information. In such cases, you can use the mono image
sensor instead of the color sensor. The mono image sensor pipeline has a lot of advantages over the color sensor processing: computational cost and higher resolution because of
a single channel, and also reduced errors while doing image reconstruction using demosaic in the color sensor processing.</p>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>Black level correction: Black level leads to the whitening of image in dark region and perceived loss of overall
contrast. The Blacklevelcorrection algorithm corrects the black and white levels of the overall image.</li>
<li>BPC (Bad pixel correction): Using median filter for BPC. An image sensor may have a certain number of defective/bad pixels that may be the result of manufacturing faults or variations in pixel voltage levels based on temperature or exposure. Bad pixel correction module removes defective pixels.</li>
<li>Gain Control: The Gain control module improves the overall brightness of the image.</li>
<li>Quantization and Dithering: Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction: Gamma correction improves the overall brightness of image.</li>
<li>Autoexposure correction: Using the CLAHE algorithm to improve brightness and contrast of the image.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-mono.png"><img alt="isp-mono" class="image" src="_images/isp-mono.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>You can dynamically configure the following parameters to the pipeline.</p>
<table border="1" class="docutils" id="id26">
<caption><span class="caption-text">Runtime Parameters for the Pipeline</span><a class="headerlink" href="#id26" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="22%" />
<col width="78%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>lgain</td>
<td>To configure gain value for the luminence channel.</td>
</tr>
<tr class="row-odd"><td>gamma_lut</td>
<td>Lookup table for gamma values.</td>
</tr>
<tr class="row-even"><td>rows</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-odd"><td>cols</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-even"><td>clip</td>
<td>clip is used to set the threshold for contrast limit
in the processing</td>
</tr>
<tr class="row-odd"><td>tilesY</td>
<td>The image is divided into tiles in the CLAHE. The
tilesY represents the number of tiles in Y direction.</td>
</tr>
<tr class="row-even"><td>tilesX</td>
<td>The image is divided into tiles in the CLAHE. The
tilesY represents the number of tiles in X direction.</td>
</tr>
</tbody>
</table>
<p>You can also use the following compile-time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id27">
<caption><span class="caption-text">Compile-Time Parameters for the Pipeline</span><a class="headerlink" href="#id27" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be a multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_SRC_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with the above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>         void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                            ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                            int height,
                                            int width,
                                            uint16_t lgain,
                                            unsigned char gamma_lut[256],
                                            int clip,
                                            int tilesY,
                                            int tilesX) {

         #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
         #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
         #pragma HLS INTERFACE m_axi      port=gamma_lut offset=slave  bundle=gmem3 depth=256

         #pragma HLS INTERFACE s_axilite  port=clip
         #pragma HLS INTERFACE s_axilite  port=tilesY
         #pragma HLS INTERFACE s_axilite  port=tilesX
         #pragma HLS INTERFACE s_axilite  port=return

         #pragma HLS ARRAY_PARTITION variable=_lut1 dim=3 complete
         #pragma HLS ARRAY_PARTITION variable=_lut2 dim=3 complete


                         if (!flag) {
                                 ISPpipeline(img_inp, img_out, height, width, lgain, gamma_lut, _lut1, _lut2, _clipCounter, clip, tilesX,
                                                         tilesY);
                                 flag = 1;

                         } else {
                                 ISPpipeline(img_inp, img_out, height, width, lgain, gamma_lut, _lut2, _lut1, _clipCounter, clip, tilesX,
                                                         tilesY);
                                 flag = 0;
                         }
                 }

         void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
  ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
  unsigned short height,
  unsigned short width,
  uint16_t lgain,
  unsigned char gamma_lut[256],
  ap_uint&lt;HIST_COUNTER_BITS&gt; _lutw[TILES_Y_MAX][TILES_X_MAX][(XF_NPIXPERCYCLE(XF_NPPC) &lt;&lt; 1)]
                                  [1 &lt;&lt; XF_DTPIXELDEPTH(XF_LTM_T, XF_NPPC)],
  ap_uint&lt;HIST_COUNTER_BITS&gt; _lutr[TILES_Y_MAX][TILES_X_MAX][(XF_NPIXPERCYCLE(XF_NPPC) &lt;&lt; 1)]
                                  [1 &lt;&lt; XF_DTPIXELDEPTH(XF_LTM_T, XF_NPPC)],
  ap_uint&lt;CLIP_COUNTER_BITS&gt; _clipCounter[TILES_Y_MAX][TILES_X_MAX],
  int clip,
  int tilesY,
  int tilesX) {

                 #pragma HLS INLINE OFF

                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt; imgInput1(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2&gt; imgInput2(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DPC_OUT&gt; dpc_out(height, width);
                         xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT&gt; gain_out(height, width);
                         xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IMPOP&gt; impop(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST&gt; _dst(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_AEC_IN&gt; aecin(height, width);
                         xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt; _imgOutput(height, width);


                 #pragma HLS DATAFLOW


                         CLAHE_T obj;

                         const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));

                         float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1;

                         float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
unsigned int blc_config_1 = (int)(mul_fact * 65536); // mul_fact int Q16_16 format
unsigned int blc_config_2 = BLACK_LEVEL;

                         xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_1&gt;(img_inp, imgInput1);
                         xf::cv::blackLevelCorrection&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 16, 15, 1, XF_CV_DEPTH_IN_1, XF_CV_DEPTH_IN_2&gt;(imgInput1, imgInput2, blc_config_2,
                                                                                                                                                                                         blc_config_1);

                         xf::cv::medianBlur&lt;WINDOW_SIZE, XF_BORDER_REPLICATE, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_IN_2, XF_CV_DEPTH_DPC_OUT&gt;(imgInput2, dpc_out);
                         xf::cv::gaincontrol_mono&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DPC_OUT, XF_CV_DEPTH_GAIN_OUT&gt;(dpc_out, gain_out, lgain);

                         if (XF_DST_T == XF_8UC1) {
                                 fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_GAIN_OUT, XF_CV_DEPTH_AEC_IN&gt;(gain_out, aecin, height, width);
                         } else {
                                 xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPC, XF_CV_DEPTH_GAIN_OUT, XF_CV_DEPTH_AEC_IN&gt;(gain_out, aecin);
                         }

                         obj.process(_dst, aecin, _lutw, _lutr, _clipCounter, height, width, clip, tilesY, tilesX);

                         xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_DST, XF_CV_DEPTH_OUT&gt;(_dst, _imgOutput, gamma_lut);

                         xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_OUT&gt;(_imgOutput, img_out);
                 }
</pre></div>
</div>
</div>
<div class="section" id="isp-201rgbir">
<span id="id14"></span><h2>RGB-IR image Sensor Processing Pipeline<a class="headerlink" href="#isp-201rgbir" title="Permalink to this headline">¶</a></h2>
<p>This Image Sensor Processing (ISP) pipeline works on a raw bayer pattern image that has IR data at some pixel loactions. It creates a fully processed RGB image and an IR image.</p>
<p>This ISP includes following blocks:</p>
<ul class="simple">
<li>RGBIR to Bayer: This module converts the input image with R,G,B,IR pixel data into a standard bayer pattern image along with a full IR data image.</li>
<li>Gain Control: The Gain control module improves the overall brightness of the image.</li>
<li>Demosaicing: The demosaic module reconstructs RGB pixels from the input Bayer image (RGGB,BGGR,RGBG,GRGB).</li>
<li>Auto white balance: The AWB module improves color balance of the image by using  image statistics.</li>
<li>Quantization and Dithering: Quantization and Dithering performs the uniform quantization to also reduce higher bit depth to lower bit depths.</li>
<li>Gamma correction: Gamma correction improves the overall brightness of image.</li>
<li>Color space conversion: Converting RGB image to YUV422 (YUYV) image for HDMI display purpose.RGB2YUYV converts the RGB image into Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<p><a class="image reference internal" href="_images/isp-rgbir.png"><img alt="isp-rgbir" class="image" src="_images/isp-rgbir.png" style="width: 1000px;" /></a></p>
<p>Current design example demonstrates how to use ISP functions in a pipeline.</p>
<p>You can dynamically configure the following parameters to the pipeline.</p>
<table border="1" class="docutils" id="id28">
<caption><span class="caption-text">Runtime Parameters for the Pipeline</span><a class="headerlink" href="#id28" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the blue channel.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.first 256 will be R,
next 256 values are G gamma and last 256 values are
B values</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable AWB algorithm</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are ignored while computing
min and max to improve quality.</td>
</tr>
<tr class="row-odd"><td>height</td>
<td>The number of rows in the image or height of the
image.</td>
</tr>
<tr class="row-even"><td>width</td>
<td>The number of columns in the image or width of the
image.</td>
</tr>
<tr class="row-odd"><td>R_IR_C1_Wgts</td>
<td>5x5 Weights to calculate R at IR location for constellation1</td>
</tr>
<tr class="row-even"><td>R_IR_C2_Wgts</td>
<td>5x5 Weights to calculate R at IR location for constellation2</td>
</tr>
<tr class="row-odd"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R location</td>
</tr>
<tr class="row-even"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R location</td>
</tr>
<tr class="row-odd"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B location</td>
</tr>
<tr class="row-even"><td>sub_wgts</td>
<td>Weights to perform weighted subtraction of IR
image from RGB image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel, sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
</tbody>
</table>
<p>You can also use the following compile-time parameters to the pipeline.</p>
<table border="1" class="docutils" id="id29">
<caption><span class="caption-text">Compile-Time Parameters for the Pipeline</span><a class="headerlink" href="#id29" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be a multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input image.
Supported formats are BGGR, GRBG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type;supported pixel widths are 8,10,12,16</td>
</tr>
</tbody>
</table>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>            extern &quot;C&quot; {
            void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                                       ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                                       ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* ir_img_out,
                                                       int height,
                                                       int width,
                                                       uint16_t rgain,
                                                       uint16_t bgain,
                                                       char R_IR_C1_wgts[25],
                                                       char R_IR_C2_wgts[25],
                                                       char B_at_R_wgts[25],
                                                       char IR_at_R_wgts[9],
                                                       char IR_at_B_wgts[9],
                                                       char sub_wgts[4],
                                                       unsigned char gamma_lut[256 * 3],
                                                       unsigned char mode_reg,
                                                       uint16_t pawb) {
            // clang-format off
            #pragma HLS INTERFACE m_axi     port=img_inp  offset=slave bundle=gmem1
            #pragma HLS INTERFACE m_axi     port=img_out  offset=slave bundle=gmem2
            #pragma HLS INTERFACE m_axi     port=ir_img_out  offset=slave bundle=gmem3
            #pragma HLS INTERFACE m_axi     port=R_IR_C1_wgts  offset=slave bundle=gmem4
            #pragma HLS INTERFACE m_axi     port=R_IR_C2_wgts  offset=slave bundle=gmem4
            #pragma HLS INTERFACE m_axi     port=B_at_R_wgts  offset=slave bundle=gmem4
            #pragma HLS INTERFACE m_axi     port=IR_at_R_wgts  offset=slave bundle=gmem4
            #pragma HLS INTERFACE m_axi     port=IR_at_B_wgts  offset=slave bundle=gmem4
            #pragma HLS INTERFACE m_axi     port=sub_wgts  offset=slave bundle=gmem5
            #pragma HLS INTERFACE m_axi     port=gamma_lut  offset=slave bundle=gmem6

            // clang-format on

            // clang-format off
            #pragma HLS ARRAY_PARTITION variable=hist0_awb complete dim=1
            #pragma HLS ARRAY_PARTITION variable=hist1_awb complete dim=1

                    // clang-format on

                    if (!flag) {
                            ISPpipeline(img_inp, img_out, ir_img_out, height, width, hist0_awb, hist1_awb, igain_0, igain_1, rgain, bgain,
                                                    R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, gamma_lut, mode_reg,
                                                    pawb);
                            flag = 1;

                    } else {
                            ISPpipeline(img_inp, img_out, ir_img_out, height, width, hist1_awb, hist0_awb, igain_1, igain_0, rgain, bgain,
                                                    R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, gamma_lut, mode_reg,
                                                    pawb);
                            flag = 0;
                    }
            }

            void ISPpipeline(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,
                                             ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,
                                             ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* ir_img_out,
                                             unsigned short height,
                                             unsigned short width,
                                             uint32_t hist0[3][HIST_SIZE],
                                             uint32_t hist1[3][HIST_SIZE],
                                             int gain0[3],
                                             int gain1[3],
                                             uint16_t rgain,
                                             uint16_t bgain,
                                             char R_IR_C1_wgts[25],
                                             char R_IR_C2_wgts[25],
                                             char B_at_R_wgts[25],
                                             char IR_at_R_wgts[9],
                                             char IR_at_B_wgts[9],
                                             char sub_wgts[4],
                                             unsigned char gamma_lut[256 * 3],
                                             unsigned char mode_reg,
                                             uint16_t pawb) {
            // clang-format off
            #pragma HLS INLINE OFF
                    // clang-format on
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInput&gt; imgInput(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInputCopy1&gt; imgInputCopy1(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInputCopy2&gt; imgInputCopy2(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_fullir_out&gt; fullir_out(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_rggb_out&gt; rggb_out(height, width);
                    xf::cv::Mat&lt;XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_gain_out&gt; gain_out(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_demosaic_out&gt; demosaic_out(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_demoOut_final&gt; demoOut_final(height, width);
                    xf::cv::Mat&lt;XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_ltm_in&gt; ltm_in(height, width);
                    xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__dst&gt; _dst(height, width);
                    xf::cv::Mat&lt;XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_aecin&gt; aecin(height, width);
                    xf::cv::Mat&lt;XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__imgOutput&gt; _imgOutput(height, width);

            // clang-format off
            #pragma HLS DATAFLOW
                    // clang-format on
                    const int Q_VAL = 1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC));

                    float thresh = (float)pawb / 256;
                    float inputMax = (1 &lt;&lt; (XF_DTPIXELDEPTH(XF_SRC_T, XF_NPPC))) - 1; // 65535.0f;

                    float mul_fact = (inputMax / (inputMax - BLACK_LEVEL));
unsigned int blc_config_1 = (int)(mul_fact * 65536); // mul_fact int Q16_16 format
unsigned int blc_config_2 = BLACK_LEVEL;

                    xf::cv::Array2xfMat&lt;INPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_imgInput&gt;(img_inp, imgInput);

                    xf::cv::rgbir2bayer&lt;FILTERSIZE1, FILTERSIZE2, XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_BORDER_CONSTANT, XF_USE_URAM, XF_CV_DEPTH_imgInput, XF_CV_DEPTH_rggb_out, XF_CV_DEPTH_fullir_out, XF_CV_DEPTH_3XWIDTH&gt;(
                            imgInput, R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, rggb_out, fullir_out);

                    xf::cv::gaincontrol&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_rggb_out, XF_CV_DEPTH_gain_out&gt;(rggb_out, gain_out, rgain, bgain);
                    xf::cv::demosaicing&lt;XF_BAYER_PATTERN, XF_SRC_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_gain_out, XF_CV_DEPTH_demosaic_out&gt;(gain_out, demosaic_out);

                    function_awb&lt;XF_DST_T, XF_DST_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, 0, XF_CV_DEPTH_demosaic_out, XF_CV_DEPTH_ltm_in&gt;(demosaic_out, ltm_in, hist0, hist1, gain0, gain1, height, width, mode_reg, thresh);

                    if (XF_DST_T == XF_8UC3) {
                            fifo_copy&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_ltm_in, XF_CV_DEPTH_aecin&gt;(ltm_in, aecin, height, width);
                    } else {
                            xf::cv::xf_QuatizationDithering&lt;XF_DST_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, 256, Q_VAL, XF_NPPCXF_CV_DEPTH_ltm_in, XF_CV_DEPTH_aecin&gt;(ltm_in, aecin);
                    }
                    xf::cv::gammacorrection&lt;XF_LTM_T, XF_LTM_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_aecin, XF_CV_DEPTH__dst&gt;(aecin, _dst, gamma_lut);
                    xf::cv::rgb2yuyv&lt;XF_LTM_T, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__dst, XF_CV_DEPTH__imgOutput&gt;(_dst, _imgOutput);

                    xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_16UC1, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH__imgOutput&gt;(_imgOutput, img_out);
                    xf::cv::xfMat2Array&lt;OUTPUT_PTR_WIDTH, XF_SRC_T, XF_HEIGHT, XF_WIDTH, XF_NPPC, XF_CV_DEPTH_fullir_out&gt;(fullir_out, ir_img_out);
            }
</pre></div>
</div>
</div>
<div class="section" id="isp-201multistream">
<span id="id15"></span><h2>Image Sensor Processing Multistream Pipeline<a class="headerlink" href="#isp-201multistream" title="Permalink to this headline">¶</a></h2>
<p>The ISP multistream pipeline allows you to process input from multiple streams using one instance of ISP.
Current multistream pipeline processes four streams in a round-robin method with input TYPE XF_16UC1
and output TYPE XF_8UC3(RGB). After the color conversion from the RGB to the YUV colorspace, the output TYPE is XF_16UC1(YUYV).</p>
<p>This ISP pipeline includes 19 modules, they are as follows:</p>
<ul class="simple">
<li><strong>Extract Exposure Frames:</strong> The Extract Exposure Frames module returns
the Short Exposure Frame and Long Exposure Frame from the input frame
using the Digital overlap parameter.</li>
<li><strong>HDR Merge:</strong> The HDR Merge module generates the HDR
image from a set of different exposure frames. Usually, image sensors
have limited dynamic range and it is difficult to get HDR image with
single image capture. From the sensor, the frames are collected with
different exposure times and will get different exposure frames.
HDR Merge will generate the HDR frame with those exposure frames.</li>
<li><strong>HDR Decompand:</strong> This module decompands or decompresses a piecewise
linear (PWL) companded data. Companding is performed in image sensors
not capable of high bitwidth during data transmission. This decompanding
module supports Bayer raw data with four knee point PWL mapping and equations
are provided for 12-bit to 16-bit conversion.</li>
<li><strong>RGBIR to Bayer (RGBIR):</strong> This module converts the input image with
R, G, B, IR pixel data into a standard Bayer pattern image along with
a full IR data image.</li>
<li><strong>Auto Exposure Compensation (AEC):</strong> This module automatically
attempts to correct the exposure level of captured image and also
improves contrast of the image.</li>
<li><strong>Black Level Correction (BLC):</strong> This module corrects the black and white
levels of the overall image. Black level leads to the whitening of
image in dark regions and perceived loss of overall contrast.</li>
<li><strong>Bad Pixel Correction (BPC):</strong> This module removes defective/bad pixels
from an image sensor resulting from of manufacturing faults or variations
in pixel voltage levels based on temperature or exposure.</li>
<li><strong>Degamma:</strong> This module linearizes the input from sensor in order to facilitate ISP processing that operates on linear domain.</li>
<li><strong>Lens Shading Correction (LSC):</strong> This module corrects the darkening toward
the edge of the image caused by camera lens limitations. This darkening
effect is also known as vignetting.</li>
<li><strong>Gain Control:</strong> This module improves the overall brightness of the image.</li>
<li><strong>Demosaicing:</strong> This module reconstructs RGB pixels from the input Bayer
image (RGGB, BGGR, RGBG, GRGB).</li>
<li><strong>Auto White Balance (AWB):</strong> This module improves color balance of the
image by using image statistics.</li>
<li><strong>Color Correction Matrix (CCM):</strong> This module converts the input image
color format to output image color format using the Color Correction Matrix
provided by the user (CCM_TYPE).</li>
<li><strong>Quantization &amp; Dithering (QnD):</strong> This module is a tone-mapper that
dithers input image using Floyd-Steinberg dithering method. It is commonly
used by image manipulation software, for example when an image is converted
into GIF format each pixel intensity value is quantized to 8 bits i.e. 256
colors.</li>
<li><strong>Global Tone Mapping (GTM):</strong> This module is a tone-mapper that reduces
the dynamic range from higher range to display range using tone mapping.</li>
<li><strong>Local Tone Mapping (LTM):</strong> This module is a tone-mapper that takes pixel
neighbor statistics into account and produces images with more contrast and
brightness.</li>
<li><strong>Gamma Correction:</strong> This module improve the overall brightness of the image.</li>
<li><strong>3DLUT:</strong> The 3D LUT module operates on three independent parameters.
This drastically increases the number of mapped indexes to value pairs.
For example, a combination of 3 individual 1D LUTs can map 2^n * 3 values
where n is the bit depth, whereas a 3D LUT processing 3 channels will have
2^n * 2^n * 2^n possible values.</li>
<li><strong>Color Space Conversion (CSC):</strong> The CSS module converts RGB image to
YUV422(YUYV) image for HDMI display purpose. RGB2YUYV converts the RGB image
into Y channel for every pixel and U and V for alternating pixels.</li>
</ul>
<p class="rubric">ISP multistream Diagram</p>
<a class="image reference internal image-reference" href="_images/ISP_Multi_Diagram.PNG"><img alt="_images/ISP_Multi_Diagram.PNG" class="image" src="_images/ISP_Multi_Diagram.PNG" style="width: 1000px;" /></a>
<p class="rubric">Parameter Descriptions</p>
<table border="1" class="docutils" id="id30">
<caption><span class="caption-text">Runtime Parameter</span><a class="headerlink" href="#id30" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>dcp_params_16to12</td>
<td>Params to converts the 16bit
input image bit depth to 12bit.</td>
</tr>
<tr class="row-odd"><td>dcp_params_12to16</td>
<td>Params to converts the 12bit
input image bit depth to 16bit.</td>
</tr>
<tr class="row-even"><td>R_IR_C1_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation1.</td>
</tr>
<tr class="row-odd"><td>R_IR_C2_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation2.</td>
</tr>
<tr class="row-even"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R
location.</td>
</tr>
<tr class="row-odd"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R
location.</td>
</tr>
<tr class="row-even"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B
location.</td>
</tr>
<tr class="row-odd"><td>sub_wgts</td>
<td>Weights to perform weighted
subtraction of IR image from RGB
image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel,
sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
<tr class="row-even"><td>wr_hls</td>
<td>Lookup table for weight values.
Computing the weights LUT in host
side and passing as input to the
function.</td>
</tr>
<tr class="row-odd"><td>array_params</td>
<td>Parameters added in one array for
multistream pipeline.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.
First 256 will be R, next 256
values are G and last 256 values
are B.</td>
</tr>
<tr class="row-odd"><td>dgam_params</td>
<td>Array containing upper limit,
slope, and intercept of linear
equations for Red, Green, and
Blue colour.</td>
</tr>
<tr class="row-even"><td>c1</td>
<td>To retain the details in bright
area using, c1 in the tone
mapping.</td>
</tr>
<tr class="row-odd"><td>c2</td>
<td>Efficiency factor, ranges from
0.5 to 1 based on output device
dynamic range.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id31">
<caption><span class="caption-text">Compile Time Parameter</span><a class="headerlink" href="#id31" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="35%" />
<col width="31%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head" colspan="2"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td colspan="2">Maximum height of input and
output image.</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td colspan="2">Maximum width of input and output
image.</td>
</tr>
<tr class="row-even"><td>XF_SRC_T</td>
<td colspan="2">Input pixel type. Supported pixel
width is 16.</td>
</tr>
<tr class="row-odd"><td>NUM_STREAMS</td>
<td colspan="2">Total number of streams.</td>
</tr>
<tr class="row-even"><td>STRM1_ROWS</td>
<td colspan="2">Maximum number of rows to be
processed for stream 1 in one
burst.</td>
</tr>
<tr class="row-odd"><td>STRM2_ROWS</td>
<td colspan="2">Maximum number of rows to be
processed for stream 2 in one
burst.</td>
</tr>
<tr class="row-even"><td>STRM3_ROWS</td>
<td colspan="2">Maximum number of rows to be
processed for stream 3 in one
burst.</td>
</tr>
<tr class="row-odd"><td>STRM4_ROWS</td>
<td colspan="2">Maximum number of rows to be
processed for stream 4 in one
burst.</td>
</tr>
<tr class="row-even"><td>NUM_SLICES</td>
<td colspan="2">Number of slices processing in
each stream.</td>
</tr>
<tr class="row-odd"><td>BLOCK_WIDTH</td>
<td colspan="2">Maximum block width the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image width.</td>
</tr>
<tr class="row-even"><td>BLOCK_HEIGHT</td>
<td colspan="2">Maximum block height the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image height.</td>
</tr>
<tr class="row-odd"><td>XF_NPPC</td>
<td colspan="2">Number of pixels processed per
cycle.</td>
</tr>
<tr class="row-even"><td>NO_EXPS</td>
<td colspan="2">Number of exposure frames to be
merged in the module.</td>
</tr>
<tr class="row-odd"><td>W_B_SIZE</td>
<td colspan="2">W_B_SIZE is used to define the
array size for storing the weight
values for wr_hls.
W_B_SIZE should be 2^bit depth.</td>
</tr>
<tr class="row-even"><td>FILTERSIZE1</td>
<td colspan="2">Filter size for RGB pixels.</td>
</tr>
<tr class="row-odd"><td>FILTERSIZE2</td>
<td colspan="2">Filter size for IR pixels.</td>
</tr>
<tr class="row-even"><td>DGAMMA_KP</td>
<td colspan="2">Configurable number of knee
points in degamma.</td>
</tr>
<tr class="row-odd"><td>SQLUTDIM</td>
<td colspan="2">Squared value of maximum
dimension of input LUT.</td>
</tr>
<tr class="row-even"><td>LUTDIM</td>
<td colspan="2">33x33 dimension of input LUT.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id32">
<caption><span class="caption-text">Descriptions of array_params</span><a class="headerlink" href="#id32" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the
red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the
blue channel.</td>
</tr>
<tr class="row-even"><td>ggain</td>
<td>To configure gain value for the
green channel.</td>
</tr>
<tr class="row-odd"><td>pawb</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality.</td>
</tr>
<tr class="row-even"><td>bayer_p</td>
<td>The Bayer format of the RAW input
image.</td>
</tr>
<tr class="row-odd"><td>black_level</td>
<td>Black level value to adjust
overall brightness of the image.</td>
</tr>
<tr class="row-even"><td>height</td>
<td>The number of rows in the image
or height of the image.</td>
</tr>
<tr class="row-odd"><td>width</td>
<td>The number of columns in the
image or width of the image.</td>
</tr>
<tr class="row-even"><td>blk_height</td>
<td>Actual block height.</td>
</tr>
<tr class="row-odd"><td>blk_width</td>
<td>Actual block width.</td>
</tr>
<tr class="row-even"><td>lut_dim</td>
<td>Dimension of input LUT.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id33">
<caption><span class="caption-text">Compile time flags</span><a class="headerlink" href="#id33" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>USE_HDR_FUSION</td>
<td>Flag to enable or disable HDR
fusion module.</td>
</tr>
<tr class="row-odd"><td>USE_GTM</td>
<td>Flag to enable or disable GTM
module.</td>
</tr>
<tr class="row-even"><td>USE_LTM</td>
<td>Flag to enable or disable LTM
module.</td>
</tr>
<tr class="row-odd"><td>USE_QND</td>
<td>Flag to enable or disable QND
module.</td>
</tr>
<tr class="row-even"><td>USE_RGBIR</td>
<td>Flag to enable or disable RGBIR
module.</td>
</tr>
<tr class="row-odd"><td>USE_3DLUT</td>
<td>Flag to enable or disable 3DLUT
module.</td>
</tr>
<tr class="row-even"><td>USE_DEGAMMA</td>
<td>Flag to enable or disable Degamma
module.</td>
</tr>
<tr class="row-odd"><td>USE_AEC</td>
<td>Flag to enable or disable AEC
module.</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the top-level ISP pipeline:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ISPPipeline_accel</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp1</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp2</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp3</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp4</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out1</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out2</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out3</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out4</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out_ir1</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out_ir2</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out_ir3</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out_ir4</span><span class="p">,</span>
               <span class="n">short</span> <span class="n">wr_hls</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="n">NO_EXPS</span> <span class="o">*</span> <span class="n">XF_NPPC</span> <span class="o">*</span> <span class="n">W_B_SIZE</span><span class="p">],</span>
               <span class="nb">int</span> <span class="n">dcp_params_12to16</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">R_IR_C1_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">R_IR_C2_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">B_at_R_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">IR_at_R_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">9</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">IR_at_B_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">9</span><span class="p">],</span>
               <span class="n">char</span> <span class="n">sub_wgts</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">4</span><span class="p">],</span>
               <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">18</span><span class="o">&gt;</span> <span class="n">dgam_params</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="n">DGAMMA_KP</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
               <span class="nb">float</span> <span class="n">c1</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">],</span>
               <span class="nb">float</span> <span class="n">c2</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">],</span>
               <span class="n">unsigned</span> <span class="n">short</span> <span class="n">array_params</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">11</span><span class="p">],</span>
               <span class="n">unsigned</span> <span class="n">char</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">LUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">lut1</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">LUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">lut2</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">LUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">lut3</span><span class="p">,</span>
               <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">LUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">lut4</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp1             offset=slave bundle=gmem1</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp2             offset=slave bundle=gmem2</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp3             offset=slave bundle=gmem3</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_inp4             offset=slave bundle=gmem4</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out1             offset=slave bundle=gmem5</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out2             offset=slave bundle=gmem6</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out3             offset=slave bundle=gmem7</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out4             offset=slave bundle=gmem8</span>

<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out_ir1          offset=slave bundle=gmem9</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out_ir2          offset=slave bundle=gmem10</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out_ir3          offset=slave bundle=gmem11</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=img_out_ir4          offset=slave bundle=gmem12</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=wr_hls               offset=slave bundle=gmem13</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=dcp_params_12to16    offset=slave bundle=gmem14</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=R_IR_C1_wgts         offset=slave bundle=gmem15</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=R_IR_C2_wgts         offset=slave bundle=gmem16</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=B_at_R_wgts          offset=slave bundle=gmem17</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=IR_at_R_wgts         offset=slave bundle=gmem18</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=IR_at_B_wgts         offset=slave bundle=gmem19</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=sub_wgts             offset=slave bundle=gmem20</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=dgam_params          offset=slave bundle=gmem21</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=c1                   offset=slave bundle=gmem22</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=c2                   offset=slave bundle=gmem23</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=array_params         offset=slave bundle=gmem24</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=gamma_lut            offset=slave bundle=gmem25</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=lut1                 offset=slave bundle=gmem26</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=lut2                 offset=slave bundle=gmem27</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=lut3                 offset=slave bundle=gmem28</span>
<span class="c1">#pragma HLS INTERFACE m_axi     port=lut4                 offset=slave bundle=gmem29</span>
   <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

   <span class="n">struct</span> <span class="n">ispparams_config</span> <span class="n">params</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">];</span>

   <span class="n">uint32_t</span> <span class="n">tot_rows</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="nb">int</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">];</span>
   <span class="n">static</span> <span class="n">short</span> <span class="n">wr_hls_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="n">NO_EXPS</span> <span class="o">*</span> <span class="n">XF_NPPC</span> <span class="o">*</span> <span class="n">W_B_SIZE</span><span class="p">];</span>
   <span class="n">static</span> <span class="n">unsigned</span> <span class="n">char</span> <span class="n">gamma_lut_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">];</span>
   <span class="n">static</span> <span class="nb">float</span> <span class="n">c1_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">],</span> <span class="n">c2_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">];</span>
   <span class="n">static</span> <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">18</span><span class="o">&gt;</span> <span class="n">dgam_params_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="n">DGAMMA_KP</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
   <span class="n">static</span> <span class="nb">int</span> <span class="n">dcp_params_12to16_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">];</span>
   <span class="n">static</span> <span class="n">char</span> <span class="n">R_IR_C1_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span> <span class="n">R_IR_C2_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span>
               <span class="n">B_at_R_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">25</span><span class="p">],</span> <span class="n">IR_at_R_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">9</span><span class="p">],</span>
               <span class="n">IR_at_B_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">9</span><span class="p">],</span> <span class="n">sub_wgts_tmp</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">][</span><span class="mi">4</span><span class="p">];</span>

   <span class="n">unsigned</span> <span class="n">short</span> <span class="n">height_arr</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">],</span> <span class="n">width_arr</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">];</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">dg_parms_c1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">dg_parms_c2</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">dcp_parms1</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">dcp_parms2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">dcp_parms3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="n">DEGAMMA_PARAMS_LOOP</span><span class="p">:</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dg_parms_c1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=dg_parms_c1 max=dg_parms_c1</span>
        <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">DGAMMA_KP</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=DGAMMA_KP max=DGAMMA_KP</span>
          <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
          <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">dg_parms_c2</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=dg_parms_c2 max=dg_parms_c2</span>
            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
            <span class="n">dgam_params_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dgam_params</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
         <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="n">DECOMPAND_PARAMS_LOOP</span><span class="p">:</span>
   <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span><span class="o">&lt;</span><span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dcp_parms1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=dcp_parms1 max=dcp_parms1</span>
        <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
        <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">dcp_parms2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=dcp_parms2 max=dcp_parms2</span>
          <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
          <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">dcp_parms3</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=dcp_parms3 max=dcp_parms3</span>
            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
            <span class="n">dcp_params_12to16_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">dcp_params_12to16</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>


<span class="n">C1_C2_INIT_LOOP</span><span class="p">:</span>
   <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
      <span class="n">c1_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">c1</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">c2_tmp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">c2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

<span class="p">}</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">R_B_count</span><span class="o">=</span><span class="mi">25</span><span class="p">,</span> <span class="n">IR_count</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span> <span class="n">sub_count</span><span class="o">=</span><span class="mi">4</span><span class="p">;</span>

<span class="n">RGBIR_INIT_LOOP_1</span><span class="p">:</span>
   <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>

   <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
   <span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R_B_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=R_B_count max=R_B_count</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="n">R_IR_C1_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R_IR_C1_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="n">R_IR_C2_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">R_IR_C2_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="n">B_at_R_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>  <span class="o">=</span> <span class="n">B_at_R_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="p">}</span>
   <span class="p">}</span>

<span class="n">RGBIR_INIT_LOOP_2</span><span class="p">:</span>
  <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>

<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
   <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">IR_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=IR_count max=IR_count</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="n">IR_at_R_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IR_at_R_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="n">IR_at_B_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">IR_at_B_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="n">RGBIR_INIT_LOOP_3</span><span class="p">:</span>
   <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">){</span>

<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sub_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=sub_count max=sub_count</span>
        <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

        <span class="n">sub_wgts_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_wgts</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
      <span class="p">}</span>
   <span class="p">}</span>

<span class="n">ARRAY_PARAMS_LOOP</span><span class="p">:</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=1 max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

      <span class="n">height_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">6</span><span class="p">];</span>
      <span class="n">width_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_params</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">7</span><span class="p">];</span>
      <span class="n">height_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">RD_MULT</span><span class="p">;</span>
      <span class="n">tot_rows</span> <span class="o">=</span> <span class="n">tot_rows</span> <span class="o">+</span> <span class="n">height_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">rem_rows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">height_arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
   <span class="p">}</span>
   <span class="n">constexpr</span> <span class="nb">int</span> <span class="n">glut_TC</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">;</span>

<span class="n">GAMMA_LUT_LOOP</span><span class="p">:</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
      <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">glut_TC</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=glut_TC max=glut_TC</span>
        <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

        <span class="n">gamma_lut_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>

      <span class="p">}</span>
   <span class="p">}</span>

<span class="n">WR_HLS_INIT_LOOP</span><span class="p">:</span>
   <span class="k">for</span><span class="p">(</span><span class="nb">int</span> <span class="n">n</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NUM_STREAMS max=NUM_STREAMS</span>
   <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
      <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">XF_NPPC</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=XF_NPPC max=XF_NPPC</span>
        <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
        <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NO_EXPS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=NO_EXPS max=NO_EXPS</span>
          <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
          <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">W_B_SIZE</span><span class="p">);</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=W_B_SIZE max=W_B_SIZE</span>
            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>
            <span class="n">wr_hls_tmp</span><span class="p">[</span><span class="n">n</span><span class="p">][(</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">NO_EXPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">W_B_SIZE</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">wr_hls</span><span class="p">[</span><span class="n">n</span><span class="p">][(</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">NO_EXPS</span><span class="p">)</span> <span class="o">*</span> <span class="n">W_B_SIZE</span> <span class="o">+</span> <span class="n">j</span><span class="p">];</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
   <span class="p">}</span>

   <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">pt</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">STRM1_ROWS</span><span class="p">,</span> <span class="n">STRM2_ROWS</span><span class="p">,</span> <span class="n">STRM3_ROWS</span><span class="p">,</span> <span class="n">STRM4_ROWS</span><span class="p">};</span>
   <span class="n">uint16_t</span> <span class="nb">max</span> <span class="o">=</span> <span class="n">STRM1_ROWS</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NUM_STREAMS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">)</span> <span class="nb">max</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
   <span class="p">}</span>

   <span class="n">const</span> <span class="n">uint16_t</span> <span class="n">TC</span> <span class="o">=</span> <span class="n">tot_rows</span> <span class="o">/</span> <span class="nb">max</span><span class="p">;</span>
   <span class="n">uint32_t</span> <span class="n">addrbound</span><span class="p">,</span> <span class="n">wr_addrbound</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">;</span>

   <span class="nb">int</span> <span class="n">strm_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stream_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slice_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="nb">bool</span> <span class="n">eof_awb</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
   <span class="nb">bool</span> <span class="n">eof_tm</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
   <span class="nb">bool</span> <span class="n">eof_aec</span><span class="p">[</span><span class="n">NUM_STREAMS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

   <span class="n">uint32_t</span> <span class="n">rd_offset1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rd_offset2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rd_offset3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rd_offset4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="n">uint32_t</span> <span class="n">wr_offset1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wr_offset2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wr_offset3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wr_offset4</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">TOTAL_ROWS_LOOP</span><span class="p">:</span>
   <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">tot_rows</span><span class="p">;)</span> <span class="p">{</span>
<span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
<span class="c1">#pragma HLS LOOP_TRIPCOUNT min=(XF_HEIGHT/STRM_HEIGHT)*NUM_STREAMS max=(XF_HEIGHT/STRM_HEIGHT)*NUM_STREAMS</span>
      <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

<span class="o">//</span> <span class="n">Compute</span> <span class="n">no</span><span class="o">.</span><span class="n">of</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">rem_rows</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">RD_MULT</span> <span class="o">&gt;</span> <span class="n">pt</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">])</span> <span class="p">{</span> <span class="o">//</span> <span class="n">Check</span> <span class="n">number</span> <span class="k">for</span> <span class="n">remaining</span> <span class="n">rows</span> <span class="n">of</span> <span class="mi">1</span> <span class="n">interleaved</span> <span class="n">image</span>
       <span class="n">num_rows</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">];</span>
       <span class="n">eof_awb</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">//</span> <span class="mi">1</span> <span class="n">interleaved</span> <span class="n">image</span><span class="o">/</span><span class="n">stream</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">done</span>
       <span class="n">eof_tm</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="n">eof_aec</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="n">num_rows</span> <span class="o">=</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">RD_MULT</span><span class="p">;</span>
       <span class="n">eof_awb</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="mi">1</span> <span class="n">interleaved</span> <span class="n">image</span><span class="o">/</span><span class="n">stream</span> <span class="n">done</span>
       <span class="n">eof_tm</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
       <span class="n">eof_aec</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="n">strm_id</span> <span class="o">=</span> <span class="n">stream_idx</span><span class="p">;</span>

     <span class="k">if</span> <span class="p">(</span><span class="n">stream_idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp1</span> <span class="o">+</span> <span class="n">rd_offset1</span><span class="p">,</span> <span class="n">img_out1</span> <span class="o">+</span> <span class="n">wr_offset1</span><span class="p">,</span> <span class="n">img_out_ir1</span> <span class="o">+</span> <span class="n">wr_offset1</span><span class="p">,</span> <span class="n">lut1</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                   <span class="n">height_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">STRM1_ROWS</span><span class="p">,</span> <span class="n">dgam_params_tmp</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">,</span>
                   <span class="n">hist1_awb</span><span class="p">,</span> <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">flag_awb</span><span class="p">,</span> <span class="n">eof_awb</span><span class="p">,</span> <span class="n">array_params</span><span class="p">,</span> <span class="n">gamma_lut_tmp</span><span class="p">,</span> <span class="n">wr_hls_tmp</span><span class="p">,</span>
                   <span class="n">R_IR_C1_wgts_tmp</span><span class="p">,</span> <span class="n">R_IR_C2_wgts_tmp</span><span class="p">,</span> <span class="n">B_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_B_wgts_tmp</span><span class="p">,</span>
                   <span class="n">sub_wgts_tmp</span><span class="p">,</span> <span class="n">dcp_params_12to16_tmp</span><span class="p">,</span> <span class="n">hist0_aec</span><span class="p">,</span> <span class="n">hist1_aec</span><span class="p">,</span> <span class="n">flag_aec</span><span class="p">,</span> <span class="n">eof_aec</span><span class="p">,</span> <span class="n">omin_r</span><span class="p">,</span> <span class="n">omax_r</span><span class="p">,</span>
                   <span class="n">omin_w</span><span class="p">,</span> <span class="n">omax_w</span><span class="p">,</span> <span class="n">mean1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">L_max1</span><span class="p">,</span> <span class="n">L_max2</span><span class="p">,</span> <span class="n">L_min1</span><span class="p">,</span> <span class="n">L_min2</span><span class="p">,</span> <span class="n">c1_tmp</span><span class="p">,</span> <span class="n">c2_tmp</span><span class="p">,</span> <span class="n">flag_tm</span><span class="p">,</span>
                   <span class="n">eof_tm</span><span class="p">,</span> <span class="n">stream_idx</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">);</span>
     <span class="n">rd_offset1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RD_MULT</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="p">((</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">RD_ADD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
     <span class="n">wr_offset1</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream_idx</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp2</span> <span class="o">+</span> <span class="n">rd_offset2</span><span class="p">,</span> <span class="n">img_out2</span> <span class="o">+</span> <span class="n">wr_offset2</span><span class="p">,</span> <span class="n">img_out_ir2</span> <span class="o">+</span> <span class="n">wr_offset2</span><span class="p">,</span> <span class="n">lut2</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                   <span class="n">height_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">STRM2_ROWS</span><span class="p">,</span> <span class="n">dgam_params_tmp</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">,</span>
                   <span class="n">hist1_awb</span><span class="p">,</span> <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">flag_awb</span><span class="p">,</span> <span class="n">eof_awb</span><span class="p">,</span> <span class="n">array_params</span><span class="p">,</span> <span class="n">gamma_lut_tmp</span><span class="p">,</span> <span class="n">wr_hls_tmp</span><span class="p">,</span>
                   <span class="n">R_IR_C1_wgts_tmp</span><span class="p">,</span> <span class="n">R_IR_C2_wgts_tmp</span><span class="p">,</span> <span class="n">B_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_B_wgts_tmp</span><span class="p">,</span>
                   <span class="n">sub_wgts_tmp</span><span class="p">,</span> <span class="n">dcp_params_12to16_tmp</span><span class="p">,</span> <span class="n">hist0_aec</span><span class="p">,</span> <span class="n">hist1_aec</span><span class="p">,</span> <span class="n">flag_aec</span><span class="p">,</span> <span class="n">eof_aec</span><span class="p">,</span> <span class="n">omin_r</span><span class="p">,</span> <span class="n">omax_r</span><span class="p">,</span>
                   <span class="n">omin_w</span><span class="p">,</span> <span class="n">omax_w</span><span class="p">,</span> <span class="n">mean1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">L_max1</span><span class="p">,</span> <span class="n">L_max2</span><span class="p">,</span> <span class="n">L_min1</span><span class="p">,</span> <span class="n">L_min2</span><span class="p">,</span> <span class="n">c1_tmp</span><span class="p">,</span> <span class="n">c2_tmp</span><span class="p">,</span> <span class="n">flag_tm</span><span class="p">,</span>
                   <span class="n">eof_tm</span><span class="p">,</span> <span class="n">stream_idx</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">);</span>

     <span class="n">rd_offset2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RD_MULT</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="p">((</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">RD_ADD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
     <span class="n">wr_offset2</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream_idx</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp3</span> <span class="o">+</span> <span class="n">rd_offset3</span><span class="p">,</span> <span class="n">img_out3</span> <span class="o">+</span> <span class="n">wr_offset3</span><span class="p">,</span> <span class="n">img_out_ir3</span> <span class="o">+</span> <span class="n">wr_offset3</span><span class="p">,</span> <span class="n">lut3</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                   <span class="n">height_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">STRM3_ROWS</span><span class="p">,</span> <span class="n">dgam_params_tmp</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">,</span>
                   <span class="n">hist1_awb</span><span class="p">,</span> <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">flag_awb</span><span class="p">,</span> <span class="n">eof_awb</span><span class="p">,</span> <span class="n">array_params</span><span class="p">,</span> <span class="n">gamma_lut_tmp</span><span class="p">,</span> <span class="n">wr_hls_tmp</span><span class="p">,</span>
                   <span class="n">R_IR_C1_wgts_tmp</span><span class="p">,</span> <span class="n">R_IR_C2_wgts_tmp</span><span class="p">,</span> <span class="n">B_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_B_wgts_tmp</span><span class="p">,</span>
                   <span class="n">sub_wgts_tmp</span><span class="p">,</span> <span class="n">dcp_params_12to16_tmp</span><span class="p">,</span> <span class="n">hist0_aec</span><span class="p">,</span> <span class="n">hist1_aec</span><span class="p">,</span> <span class="n">flag_aec</span><span class="p">,</span> <span class="n">eof_aec</span><span class="p">,</span> <span class="n">omin_r</span><span class="p">,</span> <span class="n">omax_r</span><span class="p">,</span>
                   <span class="n">omin_w</span><span class="p">,</span> <span class="n">omax_w</span><span class="p">,</span> <span class="n">mean1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">L_max1</span><span class="p">,</span> <span class="n">L_max2</span><span class="p">,</span> <span class="n">L_min1</span><span class="p">,</span> <span class="n">L_min2</span><span class="p">,</span> <span class="n">c1_tmp</span><span class="p">,</span> <span class="n">c2_tmp</span><span class="p">,</span> <span class="n">flag_tm</span><span class="p">,</span>
                   <span class="n">eof_tm</span><span class="p">,</span> <span class="n">stream_idx</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">);</span>
     <span class="n">rd_offset3</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RD_MULT</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="p">((</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">RD_ADD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
     <span class="n">wr_offset3</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

     <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">stream_idx</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">Streampipeline</span><span class="p">(</span><span class="n">img_inp4</span> <span class="o">+</span> <span class="n">rd_offset4</span><span class="p">,</span> <span class="n">img_out4</span> <span class="o">+</span> <span class="n">wr_offset4</span><span class="p">,</span> <span class="n">img_out_ir4</span> <span class="o">+</span> <span class="n">wr_offset4</span><span class="p">,</span> <span class="n">lut4</span><span class="p">,</span> <span class="n">num_rows</span><span class="p">,</span>
                   <span class="n">height_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">],</span> <span class="n">STRM4_ROWS</span><span class="p">,</span> <span class="n">dgam_params_tmp</span><span class="p">,</span> <span class="n">hist0_awb</span><span class="p">,</span>
                   <span class="n">hist1_awb</span><span class="p">,</span> <span class="n">igain_0</span><span class="p">,</span> <span class="n">igain_1</span><span class="p">,</span> <span class="n">flag_awb</span><span class="p">,</span> <span class="n">eof_awb</span><span class="p">,</span> <span class="n">array_params</span><span class="p">,</span> <span class="n">gamma_lut_tmp</span><span class="p">,</span> <span class="n">wr_hls_tmp</span><span class="p">,</span>
                   <span class="n">R_IR_C1_wgts_tmp</span><span class="p">,</span> <span class="n">R_IR_C2_wgts_tmp</span><span class="p">,</span> <span class="n">B_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_R_wgts_tmp</span><span class="p">,</span> <span class="n">IR_at_B_wgts_tmp</span><span class="p">,</span>
                   <span class="n">sub_wgts_tmp</span><span class="p">,</span> <span class="n">dcp_params_12to16_tmp</span><span class="p">,</span> <span class="n">hist0_aec</span><span class="p">,</span> <span class="n">hist1_aec</span><span class="p">,</span> <span class="n">flag_aec</span><span class="p">,</span> <span class="n">eof_aec</span><span class="p">,</span> <span class="n">omin_r</span><span class="p">,</span> <span class="n">omax_r</span><span class="p">,</span>
                   <span class="n">omin_w</span><span class="p">,</span> <span class="n">omax_w</span><span class="p">,</span> <span class="n">mean1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">L_max1</span><span class="p">,</span> <span class="n">L_max2</span><span class="p">,</span> <span class="n">L_min1</span><span class="p">,</span> <span class="n">L_min2</span><span class="p">,</span> <span class="n">c1_tmp</span><span class="p">,</span> <span class="n">c2_tmp</span><span class="p">,</span> <span class="n">flag_tm</span><span class="p">,</span>
                   <span class="n">eof_tm</span><span class="p">,</span> <span class="n">stream_idx</span><span class="p">,</span> <span class="n">slice_idx</span><span class="p">);</span>

     <span class="n">rd_offset4</span> <span class="o">+=</span> <span class="p">(</span><span class="n">RD_MULT</span> <span class="o">*</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="p">((</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">+</span> <span class="n">RD_ADD</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
     <span class="n">wr_offset4</span> <span class="o">+=</span> <span class="p">(</span><span class="n">num_rows</span> <span class="o">*</span> <span class="p">(</span><span class="n">width_arr</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">XF_BITSHIFT</span><span class="p">(</span><span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="o">//</span> <span class="n">Update</span> <span class="n">remaining</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
     <span class="n">rem_rows</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rem_rows</span><span class="p">[</span><span class="n">stream_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="n">RD_MULT</span><span class="p">;</span>

     <span class="o">//</span> <span class="n">Next</span> <span class="n">stream</span> <span class="n">selection</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">stream_idx</span> <span class="o">==</span> <span class="n">NUM_STREAMS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">stream_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
       <span class="n">slice_idx</span><span class="o">++</span><span class="p">;</span>

     <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="n">stream_idx</span><span class="o">++</span><span class="p">;</span>
     <span class="p">}</span>

     <span class="o">//</span> <span class="n">Update</span> <span class="n">total</span> <span class="n">rows</span> <span class="n">to</span> <span class="n">process</span>
     <span class="n">r</span> <span class="o">+=</span> <span class="n">num_rows</span> <span class="o">*</span> <span class="n">RD_MULT</span><span class="p">;</span>
   <span class="p">}</span> <span class="o">//</span> <span class="n">TOTAL_ROWS_LOOP</span>

 <span class="k">return</span><span class="p">;</span>

<span class="p">}</span>
</pre></div>
</div>
<p>Create and Launch Kernel in the Testbench:</p>
<p>The histogram needs two frames to populate the histogram and to get correct results in
the auto exposure frame. Auto white balance, GTM and other tone-mapping functions need
one extra frame in each to populate its parameters and apply those parameters to
get a correct image. For the specific example below, four iterations
are needed because the AEC, AWB, and LTM modulea are selected.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">kernel</span><span class="p">:</span>
<span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="s2">&quot;ISPPipeline_accel&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec_Weights</span><span class="p">,</span>  <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                       <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">vec_weight_size_bytes</span><span class="p">,</span>   <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">wr_hls</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_decompand_params</span><span class="p">,</span>  <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>                  <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                        <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">dcp_params_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">dcp_params_12to16</span><span class="p">));</span>

   <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C1</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>               <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                     <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">filter1_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">R_IR_C1_wgts</span><span class="p">));</span>
  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C2</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>               <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                     <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">filter1_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">R_IR_C2_wgts</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_B_at_R</span><span class="p">,</span>         <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>               <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                     <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">filter1_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">B_at_R_wgts</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_R</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>               <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                     <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">filter2_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">IR_at_R_wgts</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_B</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>               <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                     <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">filter2_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">IR_at_B_wgts</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_sub_wgts</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>                <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">sub_wgts_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">sub_wgts</span><span class="p">));</span>
  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_dgam_params</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">dgam_params_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">dgam_params</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_c1</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>       <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>             <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">c1_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">c1</span><span class="p">));</span>
  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_c2</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>       <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>             <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">c2_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">c2</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_array</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>            <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                  <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">array_size_bytes</span><span class="p">,</span>   <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">array_params</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec</span><span class="p">,</span>      <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>             <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">vec_in_size_bytes</span><span class="p">,</span>   <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">gamma_lut</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut1</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">lut_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">casted_lut1</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                    <span class="n">nullptr</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut2</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">lut_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">casted_lut2</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                    <span class="n">nullptr</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut3</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">lut_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">casted_lut3</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                    <span class="n">nullptr</span><span class="p">));</span>

  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut4</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                    <span class="n">CL_TRUE</span><span class="p">,</span>           <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                    <span class="mi">0</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">lut_in_size_bytes</span><span class="p">,</span> <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                    <span class="n">casted_lut4</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                    <span class="n">nullptr</span><span class="p">));</span>


  <span class="k">if</span><span class="p">(</span><span class="n">HDR_FUSION</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage1</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">interleaved_img1</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage2</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">interleaved_img2</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage3</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">interleaved_img3</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage4</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">interleaved_img4</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>

  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage1</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">out_img1_12bit</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage2</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">out_img1_12bit</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage3</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">out_img1_12bit</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inImage4</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">out_img1_12bit</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
  <span class="n">cl_ulong</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">cl_ulong</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">double</span> <span class="n">diff_prof</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
  <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp</span><span class="p">;</span>

  <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
  <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_sp</span><span class="p">));</span>
  <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>

  <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>
  <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>
  <span class="n">diff_prof</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">diff_prof</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;ms&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="o">//</span> <span class="n">Copying</span> <span class="n">Device</span> <span class="n">result</span> <span class="n">data</span> <span class="n">to</span> <span class="n">Host</span> <span class="n">memory</span>
  <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_outImage1</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img1</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
  <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_outImage2</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img2</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
  <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_outImage3</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img3</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
  <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_outImage4</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img4</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">USE_RGBIR</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_IRoutImage1</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir1</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_IRoutImage2</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir2</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_IRoutImage3</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir3</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">buffer_IRoutImage4</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir4</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Resource Utilization</p>
<p>The following table summarizes the resource utilization of ISP multistream generated using the Vitis
HLS 2024.1 tool on a ZCU102 board.</p>
<table border="1" class="docutils" id="id34">
<caption><span class="caption-text">ISP Multistream Resource Utilization Summary</span><a class="headerlink" href="#id34" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="19%" />
<col width="26%" />
<col width="14%" />
<col width="13%" />
<col width="13%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2"><dl class="first last docutils">
<dt>Operating Frequency</dt>
<dd>(MHz)</dd>
</dl>
</th>
<th class="head" colspan="4">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">BRAM</th>
<th class="head">DSP</th>
<th class="head">CLB
Registers</th>
<th class="head">CLB
LUT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 Pixel</td>
<td>150</td>
<td>209.5</td>
<td>325</td>
<td>60142</td>
<td>63718</td>
</tr>
</tbody>
</table>
<p class="rubric">Performance Estimate</p>
<p>The following table summarizes the performance of the ISP multistream in 1-pixel
mode as generated using the Vitis HLS 2024.1 tool on a ZCU102 board.</p>
<p>Estimated average latency is obtained by running the accel with four iterations.
The input to the accel is a 12bit non-linearized full-HD (1920x1080) image.</p>
<table border="1" class="docutils" id="id35">
<caption><span class="caption-text">ISP Multistream Performance Estimate Summary</span><a class="headerlink" href="#id35" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Average latency(ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 pixel operation (150 MHz)</td>
<td>62.742</td>
</tr>
</tbody>
</table>
<span class="target" id="isp-aio-adas"></span></div>
</div>
<div class="section" id="isp-all-in-one-adas-pipeline">
<h1>ISP all_in_one_adas Pipeline<a class="headerlink" href="#isp-all-in-one-adas-pipeline" title="Permalink to this headline">¶</a></h1>
<p>The ISP all_in_one_adas pipeline contains all the necessary functions that
will enable you to test several combinations of the image sensor
processing pipeline.</p>
<p>For example, you can test the Surround View System (SVS), INCABIN, and
Forward/Rear view pipeline using the ISP all_in_one_adas pipeline. The ISP
all_in_one_adas pipeline takes an interleaved image which contains Short
Exposure Frame (SEF) and Long Exposure Frame (LEF) as input when HDR
modules are enabled for the SVS pipeline and returns the HDR merged
output.</p>
<ul class="simple">
<li><strong>Extract Exposure Frames:</strong> The Extract Exposure Frames module returns
the Short Exposure Frame and Long Exposure Frame from the input frame
using the Digital overlap parameter.</li>
<li><strong>HDR Merge:</strong> HDR Merge module generates the High Dynamic Range
image from a set of different exposure frames. Usually, image sensors
have limited dynamic range and it’s difficult to get HDR image with
single image capture. From the sensor, the frames are collected with
different exposure times and will get different exposure frames,
HDR Merge will generate the HDR frame with those exposure frames.</li>
<li><strong>BPC (Bad Pixel Correction)</strong>: An image sensor may have a certain
number of defective/bad pixels that may be the result of
manufacturing faults or variations in pixel voltage levels based on
temperature or exposure. Bad Pixel Correction module removes
defective pixels.</li>
<li><strong>Black Level Correction:</strong> Black level leads to the whitening of
image in dark regions and perceived loss of overall contrast. The
Black Level Correction algorithm corrects the black and white levels of
the overall image.</li>
<li><strong>RGBIR to Bayer:</strong> This module converts the input image with R, G,
B, IR pixel data into a standard Bayer pattern image along with a
full IR data image.</li>
<li><strong>Gain Control</strong>: The Gain Control module improves the overall
brightness of the image.</li>
<li><strong>Demosaicing:</strong> The Demosaic module reconstructs RGB pixels from the
input Bayer image (RGGB, BGGR, RGBG, GRGB).</li>
<li><strong>Auto white balance:</strong> The AWB module improves color balance of the
image by using image statistics.</li>
<li><strong>Quantization &amp; Dithering:</strong> This algorithm dithers input image
using Floyd-Steinberg dithering method. It is commonly used by image
manipulation software, for example when an image is converted into
GIF format each pixel intensity value is quantized to 8 bits i.e. 256
colors.</li>
<li><strong>Global Tone Mapping:</strong> Reduces the dynamic range from higher range
to display range using tone mapping.</li>
<li><strong>Local Tone Mapping:</strong> Local Tone Mapping takes pixel neighbor
statistics into account and produces images with more contrast and
brightness.</li>
<li><strong>Gamma Correction:</strong> Gamma Correction improves the overall
brightness of image.</li>
<li><strong>Color Correction Matrix</strong>: Color Correction Matrix algorithm
converts the input image color format to output image color format
using the Color Correction Matrix provided by the user (CCM_TYPE).</li>
<li><strong>3DLUT:</strong> Operate on three independent parameters. This drastically
increases the number of mapped indexes to value pairs. For example, a
combination of 3 individual 1D LUTs can map 2^n * 3 values where n
is the bit depth, whereas a 3D LUT processing 3 channels will have
2^n * 2^n * 2^n possible values.</li>
<li><strong>Color Space Conversion</strong>: Converting RGB image to YUV422(YUYV)
image for HDMI display purpose. RGB2YUYV converts the RGB image into
Y channel for every pixel and U and V for alternate pixels.</li>
</ul>
<a class="image reference internal image-reference" href="_images/ISP_All_in_one_adas_Pipeline.PNG"><img alt="_images/ISP_All_in_one_adas_Pipeline.PNG" class="image" src="_images/ISP_All_in_one_adas_Pipeline.PNG" style="width: 1000px;" /></a>
<table border="1" class="docutils" id="id36">
<caption><span class="caption-text">Table: Runtime Parameter for the Pipeline</span><a class="headerlink" href="#id36" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Descriptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>height</td>
<td>The number of rows in the image
or height of the image.</td>
</tr>
<tr class="row-odd"><td>width</td>
<td>The number of columns in the
image or width of the image.</td>
</tr>
<tr class="row-even"><td>wr_hls</td>
<td>Lookup table for weight values.
Computing the weights LUT in host
side and passing as input to the
function.</td>
</tr>
<tr class="row-odd"><td>rgain</td>
<td>To configure gain value for the
red channel.</td>
</tr>
<tr class="row-even"><td>bgain</td>
<td>To configure gain value for the
blue channel.</td>
</tr>
<tr class="row-odd"><td>R_IR_C1_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation1.</td>
</tr>
<tr class="row-even"><td>R_IR_C2_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation2.</td>
</tr>
<tr class="row-odd"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R
location.</td>
</tr>
<tr class="row-even"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R
location.</td>
</tr>
<tr class="row-odd"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B
location.</td>
</tr>
<tr class="row-even"><td>sub_wgts</td>
<td>Weights to perform weighted
subtraction of IR image from RGB
image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel,
sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
<tr class="row-odd"><td>pawb</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality.</td>
</tr>
<tr class="row-even"><td>blk_height</td>
<td>Actual block height.</td>
</tr>
<tr class="row-odd"><td>blk_width</td>
<td>Actual block width.</td>
</tr>
<tr class="row-even"><td>c1</td>
<td>To retain the details in bright
area using, c1 in the tone
mapping.</td>
</tr>
<tr class="row-odd"><td>c2</td>
<td>Efficiency factor, ranges from
0.5 to 1 based on output device
dynamic range.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.
First 256 will be R, next 256
values are G and last 256 values
are B.</td>
</tr>
<tr class="row-odd"><td>mode_reg</td>
<td>Flag to enable/disable optional
module.</td>
</tr>
<tr class="row-even"><td>lutDim</td>
<td>Dimension of input lut.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id37">
<caption><span class="caption-text">Table: Description of mode_reg</span><a class="headerlink" href="#id37" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Bit position</strong></th>
<th class="head"><strong>Descriptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>mode_reg[0:0]</td>
<td>This bit of mode_reg dedicated
to enable/disable AWB module.</td>
</tr>
<tr class="row-odd"><td>mode_reg[1:1]</td>
<td>This of mode_reg dedicated to
enable/disable HDR module.</td>
</tr>
<tr class="row-even"><td>mode_reg[2:2]</td>
<td>Don’t care.</td>
</tr>
<tr class="row-odd"><td>mode_reg[3:3]</td>
<td>This bit of mode_reg dedicated
to enable/disable RGBIR module.</td>
</tr>
<tr class="row-even"><td>mode_reg[4:4]</td>
<td>This bit of mode_reg dedicated
for tone mapper, always
set to 0.</td>
</tr>
<tr class="row-odd"><td>mode_reg[5:5]</td>
<td>This bit of mode_reg dedicated
to enable/disable QnD module.</td>
</tr>
<tr class="row-even"><td>mode_reg[6:6]</td>
<td>This bit of mode_reg dedicated
to enable/disable LTM module.</td>
</tr>
<tr class="row-odd"><td>mode_reg[7:7]</td>
<td>This bit of mode_reg dedicated
to enable/disable GTM module.</td>
</tr>
<tr class="row-even"><td>mode_reg[8:8]</td>
<td>This bit of mode_reg dedicated
to enable/disable CCM module.</td>
</tr>
<tr class="row-odd"><td>mode_reg[9:9]</td>
<td>This bit of mode_reg dedicated
to enable/disable 3DLUT module.</td>
</tr>
<tr class="row-even"><td>mode_reg[10:10]</td>
<td>This bit of mode_reg dedicated
to enable/disable CSC module.</td>
</tr>
<tr class="row-odd"><td>mode_reg[15:11]</td>
<td>Don’t care.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id38">
<caption><span class="caption-text">Table: Compile Time Parameter</span><a class="headerlink" href="#id38" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and
output image.</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output
image.</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input
image. Supported formats are
XF_BAYER_RG.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type. Supported pixel
width is 16.</td>
</tr>
<tr class="row-even"><td>SQLUTDIM</td>
<td>Squared value of maximum
dimension of input LUT.</td>
</tr>
<tr class="row-odd"><td>LUTDIM</td>
<td>33x33 dimension of input LUT.</td>
</tr>
<tr class="row-even"><td>BLOCK_WIDTH</td>
<td>Maximum block width the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image width.</td>
</tr>
<tr class="row-odd"><td>BLOCK_HEIGHT</td>
<td>Maximum block height the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image height.</td>
</tr>
<tr class="row-even"><td>XF_NPPC</td>
<td>Number of pixels processed per
cycle.</td>
</tr>
<tr class="row-odd"><td>NO_EXPS</td>
<td>Number of exposure frames to be
merged in the module.</td>
</tr>
<tr class="row-even"><td>W_B_SIZE</td>
<td>W_B_SIZE is used to define the
array size for storing the weight
values for wr_hls.
W_B_SIZE should be 2^bit depth.</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the top-level ISP pipeline:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,                 /* Array2xfMat */
                       ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,                /* xfMat2Array */
                       ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out_ir,             /* xfMat2Array */
                       int height,                                        /* HDR, rgbir2bayer, fifo_copy */
                       int width,                                         /* HDR, rgbir2bayer, fifo_copy */
                       short* wr_hls,                                     /* HDR */
                       uint16_t rgain,                                    /* gaincontrol */
                       uint16_t bgain,                                    /* gaincontrol */
                       char *R_IR_C1_wgts,                                /* rgbir2bayer */
                       char *R_IR_C2_wgts,                                /* rgbir2bayer */
                       char *B_at_R_wgts,                                 /* rgbir2bayer */
                       char *IR_at_R_wgts,                                /* rgbir2bayer */
                       char *IR_at_B_wgts,                                /* rgbir2bayer */
                       char *sub_wgts,                                    /* rgbir2bayer */
                       uint16_t pawb,                                     /* awb */
                       int blk_height,                                    /* LTM */
                       int blk_width,                                     /* LTM */
                       float c1,                                          /* gtm */
                       float c2,                                          /* gtm */
                       unsigned char gamma_lut[256 * 3],                  /* gammacorrection */
                       unsigned short mode_reg,
                       ap_uint&lt;INPUT_PTR_WIDTH&gt;* lut,                     /* lut3d */
                       int lutDim                                         /* lut3d */ ){
// clang-format off
#pragma HLS INTERFACE m_axi port=img_inp          offset=slave bundle=gmem1
#pragma HLS INTERFACE m_axi port=img_out          offset=slave bundle=gmem2
#pragma HLS INTERFACE m_axi port=img_out_ir       offset=slave bundle=gmem3
#pragma HLS INTERFACE m_axi port=R_IR_C1_wgts     offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi port=R_IR_C2_wgts     offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi port=B_at_R_wgts      offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi port=IR_at_R_wgts     offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi port=IR_at_B_wgts     offset=slave bundle=gmem4
#pragma HLS INTERFACE m_axi port=sub_wgts         offset=slave bundle=gmem5
#pragma HLS INTERFACE m_axi port=gamma_lut        offset=slave bundle=gmem6
#pragma HLS INTERFACE m_axi port=wr_hls           offset=slave bundle=gmem7
#pragma HLS INTERFACE m_axi port=lut              offset=slave bundle=gmem8

#pragma HLS ARRAY_PARTITION variable=IR_at_B_wgts complete dim=1
#pragma HLS ARRAY_PARTITION variable=bgain        complete dim=1
#pragma HLS ARRAY_PARTITION variable=rgain        complete dim=1
#pragma HLS ARRAY_PARTITION variable=R_IR_C2_wgts complete dim=1
#pragma HLS ARRAY_PARTITION variable=R_IR_C1_wgts complete dim=1
#pragma HLS ARRAY_PARTITION variable=sub_wgts     complete dim=1
#pragma HLS ARRAY_PARTITION variable=IR_at_R_wgts complete dim=1
#pragma HLS ARRAY_PARTITION variable=mode_reg     complete dim=1
#pragma HLS ARRAY_PARTITION variable=pawb         complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist0_awb    complete dim=1
#pragma HLS ARRAY_PARTITION variable=hist1_awb    complete dim=1

#pragma HLS ARRAY_PARTITION variable=omin dim=1   complete
#pragma HLS ARRAY_PARTITION variable=omin dim=2   cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=omin dim=3   cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=omax dim=1   complete
#pragma HLS ARRAY_PARTITION variable=omax dim=2   cyclic factor=2
#pragma HLS ARRAY_PARTITION variable=omax dim=3   cyclic factor=2
// clang-format on
if (!flag) {
    ISPpipeline(img_inp, img_out, img_out_ir, mode_reg, height, width, wr_hls, R_IR_C1_wgts, R_IR_C2_wgts,
                B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, rgain, bgain,  hist0_awb, hist1_awb,
                igain_0, igain_1, pawb, gamma_lut, omin[0], omax[0], omin[1], omax[1], blk_height,blk_width,
                mean2, mean1, L_max2, L_max1, L_min2, L_min1, c1, c2, lut, lutDim);
     flag = 1;
    } else {
    ISPpipeline(img_inp, img_out, img_out_ir, mode_reg, height, width, wr_hls, R_IR_C1_wgts, R_IR_C2_wgts,
                B_at_R_wgts, IR_at_R_wgts, IR_at_B_wgts, sub_wgts, rgain, bgain,  hist1_awb, hist0_awb,
                igain_1, igain_0, pawb, gamma_lut, omin[1], omax[1], omin[0], omax[0], blk_height, blk_width,
                mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2, lut, lutDim);
    flag = 0;
    }
}
</pre></div>
</div>
<div class="section" id="create-and-launch-kernel-in-the-testbench">
<h2>Create and Launch Kernel in the Testbench:<a class="headerlink" href="#create-and-launch-kernel-in-the-testbench" title="Permalink to this headline">¶</a></h2>
<p>Histogram needs two frames to populate the histogram and to get correct
auto white balance results. GTM and other tone-mapping functions need
three frames to populate its parameters and apply those parameters to
get a corrected image. For the specific example below, three iterations
are needed because the GTM function is selected.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">kernel</span><span class="p">:</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="s2">&quot;ISPPipeline_accel&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">vec_in_size_bytes</span><span class="p">,</span>            <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">gamma_lut</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C1</span><span class="p">,</span>               <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">R_IR_C1_wgts</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C2</span><span class="p">,</span>               <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">R_IR_C2_wgts</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_B_at_R</span><span class="p">,</span>                <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">B_at_R_wgts</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_R</span><span class="p">,</span>               <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter2_in_size_bytes</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">IR_at_R_wgts</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_B</span><span class="p">,</span>               <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter2_in_size_bytes</span><span class="p">,</span>        <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">IR_at_B_wgts</span><span class="p">));</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_sub_wgts</span><span class="p">,</span>              <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">sub_wgts_in_size_bytes</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">sub_wgts</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">hdr_en</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec_Weights</span><span class="p">,</span>     <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                            <span class="n">CL_TRUE</span><span class="p">,</span>                  <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                            <span class="mi">0</span><span class="p">,</span>                        <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                            <span class="n">vec_weight_size_bytes</span><span class="p">,</span>    <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                            <span class="n">wr_hls</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span>
                                            <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">image_in_size_bytes</span><span class="p">,</span>
                                            <span class="n">interleaved_img</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>

    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span>
                                            <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">image_in_size_bytes</span><span class="p">,</span>
                                            <span class="n">in_img1</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut</span><span class="p">,</span>                 <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                      <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">lut_in_size_bytes</span><span class="p">,</span>            <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">casted_lut</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                        <span class="n">nullptr</span><span class="p">));</span>
    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>

    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_sp</span><span class="p">));</span>

    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>

    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>

    <span class="n">diff_prof</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">diff_prof</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot;ms&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="o">//</span> <span class="n">Copying</span> <span class="n">Device</span> <span class="n">result</span> <span class="n">data</span> <span class="n">to</span> <span class="n">Host</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rgbir_en</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDevice_ir</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Resource Utilization</p>
<p>The following table summarizes the resource utilization of ISP all_in_one_adas generated using Vitis
HLS 2022.2 tool on ZCU102 board.</p>
<table border="1" class="docutils" id="id39">
<caption><span class="caption-text">Table: ISP all_in_one_adas Resource Utilization Summary</span><a class="headerlink" href="#id39" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="30%" />
<col width="13%" />
<col width="12%" />
<col width="12%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2">Operating Frequency (MHz)</th>
<th class="head" colspan="4">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">BRAM</th>
<th class="head">DSP</th>
<th class="head">CLB
Registers</th>
<th class="head">CLB
LUT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 Pixel</td>
<td>150</td>
<td>178</td>
<td>305</td>
<td>61210</td>
<td>63566</td>
</tr>
</tbody>
</table>
<p class="rubric">Performance Estimate</p>
<p>The following table summarizes the performance of the ISP all_in_one_adas in 1-pixel
mode as generated using Vitis HLS 2022.2 tool on ZCU102 board.</p>
<p>Estimated average latency is obtained by running the accel with three iterations.
The input to the accel is an interleaved image containing one long-exposure frame
and one short-exposure frame which are both full-HD (1920x1080) images.</p>
<table border="1" class="docutils" id="id40">
<caption><span class="caption-text">Table: ISP all_in_one_adas Performance Estimate Summary</span><a class="headerlink" href="#id40" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="53%" />
<col width="47%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Average latency (ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 pixel operation (150 MHz)</td>
<td>29.509</td>
</tr>
</tbody>
</table>
<span class="target" id="isp-aio"></span></div>
</div>
<div class="section" id="isp-all-in-one-pipeline">
<h1>ISP all_in_one Pipeline:<a class="headerlink" href="#isp-all-in-one-pipeline" title="Permalink to this headline">¶</a></h1>
<p>The ISP all_in_one pipeline contains all the necessary functions that
will enable the user to test several combinations of the image sensor
processing pipeline. In this specific ISP pipeline version, optional
modules can be enabled or disabled using compile-time parameters.</p>
<p>This ISP pipeline includes 19 modules, as follows:</p>
<ul class="simple">
<li><strong>Extract Exposure Frames:</strong> The Extract Exposure Frames module returns
the Short Exposure Frame and Long Exposure Frame from the input frame
using the Digital overlap parameter.</li>
<li><strong>HDR Merge:</strong> The HDR Merge module generates the High Dynamic Range
image from a set of different exposure frames. Usually, image sensors
have limited dynamic range and it’s difficult to get HDR image with
single image capture. From the sensor, the frames are collected with
different exposure times and will get different exposure frames.
HDR Merge will generate the HDR frame with those exposure frames.</li>
<li><strong>HDR Decompand:</strong> This module decompands or decompresses a piecewise
linear (PWL) companded data. Companding is performed in image sensors
not capable of high bitwidth during data transmission. This decompanding
module supports Bayer raw data with four knee point PWL mapping and equations
are provided for 12-bit to 16-bit conversion.</li>
<li><strong>RGBIR to Bayer (RGBIR):</strong> This module converts the input image with
R, G, B, IR pixel data into a standard Bayer pattern image along with
a full IR data image.</li>
<li><strong>Auto Exposure Compensation (AEC):</strong> This module automatically
attempts to correct the exposure level of the captured image and also
improve the contrast of the image.</li>
<li><strong>Black Level Correction (BLC):</strong> This module corrects the black and white
levels of the overall image. Black level leads to the whitening of
image in dark regions and perceived loss of overall contrast.</li>
<li><strong>Bad Pixel Correction (BPC):</strong> This module removes defective/bad pixels
from an image sensor resulting from manufacturing faults or variations
in pixel voltage levels based on temperature or exposure.</li>
<li><strong>Degamma:</strong> This module linearizes the input from the sensor in order to facilitate ISP processing that operates on the linear domain.</li>
<li><strong>Lens Shading Correction (LSC):</strong> This module corrects the darkening toward
the edge of the image caused by camera lens limitations. This darkening
effect is also known as vignetting.</li>
<li><strong>Gain Control:</strong> This module improves the overall brightness of the image.</li>
<li><strong>Demosaicing:</strong> This module reconstructs RGB pixels from the input Bayer
image (RGGB, BGGR, RGBG, GRGB).</li>
<li><strong>Auto White Balance (AWB):</strong> This module improves the color balance of the
image by using image statistics.</li>
<li><strong>Color Correction Matrix (CCM):</strong> This module converts the input image
color format to the output image color format using the Color Correction Matrix
provided by the user (CCM_TYPE).</li>
<li><strong>Quantization &amp; Dithering (QnD):</strong> This module is a tone-mapper that
dithers the input image using the Floyd-Steinberg dithering method. It is commonly
used by image manipulation software, for example when an image is converted
into GIF format each pixel intensity value is quantized to 8 bits i.e., 256
colors.</li>
<li><strong>Global Tone Mapping (GTM):</strong> This module is a tone-mapper that reduces
the dynamic range from higher range to display range using tone mapping.</li>
<li><strong>Local Tone Mapping (LTM):</strong> This module is a tone-mapper that takes pixel
neighbor statistics into account and produces images with more contrast and
brightness.</li>
<li><strong>Gamma Correction:</strong> This module improve the overall brightness of the image.</li>
<li><strong>3DLUT:</strong> The 3D LUT module operates on three independent parameters.
This drastically increases the number of mapped indexes to value pairs.
For example, a combination of 3 individual 1D LUTs can map 2^n * 3 values
where n is the bit depth, whereas a 3D LUT processing 3 channels will have
2^n * 2^n * 2^n possible values.</li>
<li><strong>Color Space Conversion (CSC):</strong> The CSS module converts an RGB image to
a YUV422(YUYV) image for HDMI display purposes. RGB2YUYV converts the RGB image
into Y channel for every pixel and U and V for alternating pixels.</li>
</ul>
<a class="image reference internal image-reference" href="_images/ISP_AIO_Diagram.PNG"><img alt="_images/ISP_AIO_Diagram.PNG" class="image" src="_images/ISP_AIO_Diagram.PNG" style="width: 1000px;" /></a>
<table border="1" class="docutils" id="id41">
<caption><span class="caption-text">Table: Runtime Parameters for the Pipeline</span><a class="headerlink" href="#id41" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Descriptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>height</td>
<td>The number of rows in the image
or height of the image.</td>
</tr>
<tr class="row-odd"><td>width</td>
<td>The number of columns in the
image or width of the image.</td>
</tr>
<tr class="row-even"><td>dcp_params_16to12</td>
<td>Params to converts the 16bit
input image bit depth to 12bit.</td>
</tr>
<tr class="row-odd"><td>dcp_params_12to16</td>
<td>Params to converts the 12bit
input image bit depth to 16bit.</td>
</tr>
<tr class="row-even"><td>wr_hls</td>
<td>Lookup table for weight values.
Computing the weights LUT in host
side and passing as input to the
function.</td>
</tr>
<tr class="row-odd"><td>rgain</td>
<td>To configure gain value for the
red channel.</td>
</tr>
<tr class="row-even"><td>bgain</td>
<td>To configure gain value for the
blue channel.</td>
</tr>
<tr class="row-odd"><td>R_IR_C1_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation1.</td>
</tr>
<tr class="row-even"><td>R_IR_C2_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation2.</td>
</tr>
<tr class="row-odd"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R
location.</td>
</tr>
<tr class="row-even"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R
location.</td>
</tr>
<tr class="row-odd"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B
location.</td>
</tr>
<tr class="row-even"><td>sub_wgts</td>
<td>Weights to perform weighted
subtraction of IR image from RGB
image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel,
sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
<tr class="row-odd"><td>dgam_params</td>
<td>Array containing upper limit,
slope and intercept of linear
equations for Red, Green and
Blue colour.</td>
</tr>
<tr class="row-even"><td>pawb</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality.</td>
</tr>
<tr class="row-odd"><td>paec</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality.</td>
</tr>
<tr class="row-even"><td>blk_height</td>
<td>Actual block height.</td>
</tr>
<tr class="row-odd"><td>blk_width</td>
<td>Actual block width.</td>
</tr>
<tr class="row-even"><td>c1</td>
<td>To retain the details in bright
area using, c1 in the tone
mapping.</td>
</tr>
<tr class="row-odd"><td>c2</td>
<td>Efficiency factor, ranges from
0.5 to 1 based on output device
dynamic range.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma values.
First 256 will be R, next 256
values are G and last 256 values
are B.</td>
</tr>
<tr class="row-odd"><td>lutDim</td>
<td>Dimension of input LUT.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id42">
<caption><span class="caption-text">Table: Compile Time Flags</span><a class="headerlink" href="#id42" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>USE_HDR_FUSION</td>
<td>Flag to enable or disable HDR
fusion module.</td>
</tr>
<tr class="row-odd"><td>USE_GTM</td>
<td>Flag to enable or disable GTM
module.</td>
</tr>
<tr class="row-even"><td>USE_LTM</td>
<td>Flag to enable or disable LTM
module.</td>
</tr>
<tr class="row-odd"><td>USE_QND</td>
<td>Flag to enable or disable QND
module.</td>
</tr>
<tr class="row-even"><td>USE_RGBIR</td>
<td>Flag to enable or disable RGBIR
module.</td>
</tr>
<tr class="row-odd"><td>USE_3DLUT</td>
<td>Flag to enable or disable 3DLUT
module.</td>
</tr>
<tr class="row-even"><td>USE_DEGAMMA</td>
<td>Flag to enable or disable Degamma
module.</td>
</tr>
<tr class="row-odd"><td>USE_AEC</td>
<td>Flag to enable or disable AEC
module.</td>
</tr>
<tr class="row-even"><td>USE_AWB</td>
<td>Flag to enable or disable AWB
module.</td>
</tr>
<tr class="row-odd"><td>USE_CCM</td>
<td>Flag to enable or disable CCM
module.</td>
</tr>
<tr class="row-even"><td>USE_CSC</td>
<td>Flag to enable or disable CSC
module.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id43">
<caption><span class="caption-text">Table: Compile Time Parameter</span><a class="headerlink" href="#id43" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Description</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and
output image.</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output
image.</td>
</tr>
<tr class="row-even"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input
image. Using XF_BAYER_RG format.</td>
</tr>
<tr class="row-odd"><td>XF_SRC_T</td>
<td>Input pixel type. Supported pixel
width is 16.</td>
</tr>
<tr class="row-even"><td>DGAMMA_KP</td>
<td>Configurable number of knee
points in degamma.</td>
</tr>
<tr class="row-odd"><td>SQLUTDIM</td>
<td>Squared value of maximum
dimension of input LUT.</td>
</tr>
<tr class="row-even"><td>LUTDIM</td>
<td>33x33 dimension of input LUT.</td>
</tr>
<tr class="row-odd"><td>BLOCK_WIDTH</td>
<td>Maximum block width the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image width.</td>
</tr>
<tr class="row-even"><td>BLOCK_HEIGHT</td>
<td>Maximum block height the image is
divided into. This can be any
positive integer greater than or
equal to 32 and less than input
image height.</td>
</tr>
<tr class="row-odd"><td>XF_NPPC</td>
<td>Number of pixels processed per
cycle.</td>
</tr>
<tr class="row-even"><td>NO_EXPS</td>
<td>Number of exposure frames to be
merged in the module.</td>
</tr>
<tr class="row-odd"><td>W_B_SIZE</td>
<td>W_B_SIZE is used to define the
array size for storing the weight
values for wr_hls.
W_B_SIZE should be 2^bit depth.</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the top-level ISP pipeline:</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span> void ISPPipeline_accel(ap_uint&lt;INPUT_PTR_WIDTH&gt;* img_inp,                 /* Array2xfMat */
                        ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out,                /* xfMat2Array */
                        ap_uint&lt;OUTPUT_PTR_WIDTH&gt;* img_out_ir,             /* xfMat2Array */
                        int height,                                        /* HDR, rgbir2bayer, fifo_copy */
                        int width,                                         /* HDR, rgbir2bayer, fifo_copy */
                        short wr_hls[NO_EXPS * XF_NPPC * W_B_SIZE],        /* HDR */
                        uint16_t rgain,                                    /* gaincontrol */
                        uint16_t bgain,                                    /* gaincontrol */
                        char R_IR_C1_wgts[25],                             /* rgbir2bayer */
                        char R_IR_C2_wgts[25],                             /* rgbir2bayer */
                        char B_at_R_wgts[25],                              /* rgbir2bayer */
                        char IR_at_R_wgts[9],                              /* rgbir2bayer */
                        char IR_at_B_wgts[9],                              /* rgbir2bayer */
                        char sub_wgts[4],                                  /* rgbir2bayer */
                        int blk_height,                                    /* LTM */
                        int blk_width,                                     /* LTM */
                        float c1,                                          /* gtm */
                        float c2,                                          /* gtm */
                        unsigned char gamma_lut[256 * 3],                  /* gammacorrection */
                        ap_uint&lt;LUT_PTR_WIDTH&gt;* lut,                       /* lut3d */
                        int lutDim,                                         /* lut3d */
                        uint16_t pawb,                                      /* used to calculate thresh which is used in function_awb */
                        unsigned short bayerp,
                        int params_decompand[3][4][3],
                        ap_ufixed&lt;32, 16&gt; params_degamma[3][DEGAMMA_KP][3]){
 // clang-format off
 #pragma HLS INTERFACE m_axi port=img_inp          offset=slave bundle=gmem1
 #pragma HLS INTERFACE m_axi port=img_out          offset=slave bundle=gmem2
 #pragma HLS INTERFACE m_axi port=img_out_ir       offset=slave bundle=gmem3
 #pragma HLS INTERFACE m_axi port=R_IR_C1_wgts     offset=slave bundle=gmem4
 #pragma HLS INTERFACE m_axi port=R_IR_C2_wgts     offset=slave bundle=gmem5
 #pragma HLS INTERFACE m_axi port=B_at_R_wgts      offset=slave bundle=gmem6
 #pragma HLS INTERFACE m_axi port=IR_at_R_wgts     offset=slave bundle=gmem7
 #pragma HLS INTERFACE m_axi port=IR_at_B_wgts     offset=slave bundle=gmem8
 #pragma HLS INTERFACE m_axi port=sub_wgts         offset=slave bundle=gmem9
 #pragma HLS INTERFACE m_axi port=gamma_lut        offset=slave bundle=gmem10
 #pragma HLS INTERFACE m_axi port=wr_hls           offset=slave bundle=gmem11
 #pragma HLS INTERFACE m_axi port=lut              offset=slave bundle=gmem12

 #pragma HLS INTERFACE m_axi port=params_decompand offset=slave bundle=gmem13
 #pragma HLS INTERFACE m_axi port=params_degamma   offset=slave bundle=gmem14
 #pragma HLS INTERFACE m_axi port=img_out_decom    offset=slave bundle=gmem15
 #pragma HLS INTERFACE m_axi port=img_out_deggama  offset=slave bundle=gmem16

 #pragma HLS ARRAY_PARTITION variable=hist0_awb    complete dim=1
 #pragma HLS ARRAY_PARTITION variable=hist1_awb    complete dim=1
 #pragma HLS ARRAY_PARTITION variable=omin dim=1   complete
 #pragma HLS ARRAY_PARTITION variable=omin dim=2   cyclic factor=2
 #pragma HLS ARRAY_PARTITION variable=omin dim=3   cyclic factor=2
 #pragma HLS ARRAY_PARTITION variable=omax dim=1   complete
 #pragma HLS ARRAY_PARTITION variable=omax dim=2   cyclic factor=2
 #pragma HLS ARRAY_PARTITION variable=omax dim=3   cyclic factor=2
 // clang-format on

 static short wr_hls_tmp[NO_EXPS * XF_NPPC * W_B_SIZE];

 WR_HLS_INIT_LOOP:
    for (int k = 0; k &lt; XF_NPPC; k++) {
 // clang-format off
 #pragma HLS LOOP_TRIPCOUNT min=XF_NPPC max=XF_NPPC
       // clang-format on
       for (int i = 0; i &lt; NO_EXPS; i++) {
 // clang-format off
 #pragma HLS LOOP_TRIPCOUNT min=NO_EXPS max=NO_EXPS
          // clang-format on
          for (int j = 0; j &lt; (W_B_SIZE); j++) {
 // clang-format off
 #pragma HLS LOOP_TRIPCOUNT min=W_B_SIZE max=W_B_SIZE
             // clang-format on
             wr_hls_tmp[(i + k * NO_EXPS) * W_B_SIZE + j] = wr_hls[(i + k * NO_EXPS) * W_B_SIZE + j];
          }
       }
   }


 if (!flag) {
        ISPpipeline(img_inp, img_out, img_out_ir, height, width, wr_hls_tmp, R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts,
             IR_at_R_wgts, IR_at_B_wgts, sub_wgts, params_decompand, params_degamma, bayerp, rgain, bgain,
             hist0_awb, hist1_awb, igain_0, igain_1, pawb, gamma_lut, omin[0], omax[0], omin[1], omax[1],
             blk_height, blk_width, mean2, mean1, L_max2, L_max1, L_min2, L_min1, c1, c2, lut, lutDim, hist0_aec,
             hist1_aec, img_out_decom, img_out_deggama);
        flag = 1;

 } else {
        ISPpipeline(img_inp, img_out, img_out_ir, height, width, wr_hls_tmp, R_IR_C1_wgts, R_IR_C2_wgts, B_at_R_wgts,
            IR_at_R_wgts, IR_at_B_wgts, sub_wgts, params_decompand, params_degamma, bayerp, rgain, bgain,
            hist1_awb, hist0_awb, igain_1, igain_0, pawb, gamma_lut, omin[1], omax[1], omin[0], omax[0],
            blk_height, blk_width, mean1, mean2, L_max1, L_max2, L_min1, L_min2, c1, c2, lut, lutDim, hist1_aec,
            hist0_aec, img_out_decom, img_out_deggama);
        flag = 0;
 }
}
</pre></div>
</div>
<div class="section" id="id16">
<h2>Create and Launch Kernel in the Testbench:<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h2>
<p>The histogram needs two frames to populate the histogram array and to get correct results in the
auto exposure frame. Auto white balance, GTM and other tone-mapping functions need
one extra frame in each to populate its parameters and apply those parameters to
get a correct image. For the specific example below, four iterations
are needed because the AEC, AWB, and LTM modules are selected.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">kernel</span><span class="p">:</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">cl</span><span class="p">::</span><span class="n">Kernel</span> <span class="n">kernel</span><span class="p">(</span><span class="n">program</span><span class="p">,</span> <span class="s2">&quot;ISPPipeline_accel&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">err</span><span class="p">));</span>

    <span class="nb">int</span> <span class="n">loop_count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loop_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec</span><span class="p">,</span>          <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">vec_in_size_bytes</span><span class="p">,</span>         <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">gamma_lut</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C1</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">R_IR_C1_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_R_IR_C2</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">R_IR_C2_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_B_at_R</span><span class="p">,</span>         <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter1_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">B_at_R_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_R</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter2_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">IR_at_R_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_IR_at_B</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                   <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">filter2_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">IR_at_B_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_sub_wgts</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                    <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                          <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">sub_wgts_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">sub_wgts</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_decompand_params</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                                  <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">decompand_params_in_size_bytes</span><span class="p">,</span>     <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">params_decomand</span><span class="p">));</span>

        <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_degamma_params</span><span class="p">,</span>          <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                                  <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">degamma_params_in_size_bytes</span><span class="p">,</span>       <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">params_degamma</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">USE_HDR_FUSION</span><span class="p">)</span> <span class="p">{</span>
           <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inVec_Weights</span><span class="p">,</span>        <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                            <span class="n">CL_TRUE</span><span class="p">,</span>                        <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                            <span class="mi">0</span><span class="p">,</span>                              <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                            <span class="n">vec_weight_size_bytes</span><span class="p">,</span>          <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                            <span class="n">wr_hls</span><span class="p">));</span>

           <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">interleaved_img</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">else</span> <span class="p">{</span>
           <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">imageToDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="n">image_in_size_bytes</span><span class="p">,</span> <span class="n">out_img_12bit</span><span class="o">.</span><span class="n">data</span><span class="p">));</span>
       <span class="p">}</span>

           <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueWriteBuffer</span><span class="p">(</span><span class="n">buffer_inLut</span><span class="p">,</span>                <span class="o">//</span> <span class="n">buffer</span> <span class="n">on</span> <span class="n">the</span> <span class="n">FPGA</span>
                                        <span class="n">CL_TRUE</span><span class="p">,</span>                            <span class="o">//</span> <span class="n">blocking</span> <span class="n">call</span>
                                        <span class="mi">0</span><span class="p">,</span>                                  <span class="o">//</span> <span class="n">buffer</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">lut_in_size_bytes</span><span class="p">,</span>                  <span class="o">//</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span>
                                        <span class="n">casted_lut</span><span class="p">,</span>                         <span class="o">//</span> <span class="n">Pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">data</span> <span class="n">to</span> <span class="n">copy</span>
                                        <span class="n">nullptr</span><span class="p">));</span>
    <span class="o">//</span> <span class="n">Profiling</span> <span class="n">Objects</span>
    <span class="n">cl_ulong</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cl_ulong</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">double</span> <span class="n">diff_prof</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
    <span class="n">cl</span><span class="p">::</span><span class="n">Event</span> <span class="n">event_sp</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Launch</span> <span class="n">the</span> <span class="n">kernel</span>
    <span class="n">OCL_CHECK</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">enqueueTask</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event_sp</span><span class="p">));</span>

    <span class="n">clWaitForEvents</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">const</span> <span class="n">cl_event</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">event_sp</span><span class="p">);</span>

    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_START</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">);</span>

    <span class="n">event_sp</span><span class="o">.</span><span class="n">getProfilingInfo</span><span class="p">(</span><span class="n">CL_PROFILING_COMMAND_END</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">);</span>

    <span class="n">diff_prof</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">diff_prof</span> <span class="o">/</span> <span class="mi">1000000</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">exec_sum</span> <span class="o">=</span> <span class="n">exec_sum</span> <span class="o">+</span> <span class="n">diff_prof</span><span class="p">;</span>

    <span class="o">//</span> <span class="n">Copying</span> <span class="n">Device</span> <span class="n">result</span> <span class="n">data</span> <span class="n">to</span> <span class="n">Host</span> <span class="n">memory</span>
    <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDevice</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_size_bytes</span><span class="p">,</span> <span class="n">out_img</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">USE_RGBIR</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="o">.</span><span class="n">enqueueReadBuffer</span><span class="p">(</span><span class="n">imageFromDevice_ir</span><span class="p">,</span> <span class="n">CL_TRUE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_out_ir_size_bytes</span><span class="p">,</span> <span class="n">out_img_ir</span><span class="o">.</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">Resource Utilization</p>
<p>The following table summarizes the resource utilization of ISP all_in_one generated using Vitis
HLS 2023.1 tool on ZCU102 board.</p>
<table border="1" class="docutils" id="id44">
<caption><span class="caption-text">Table: ISP all_in_one Resource Utilization Summary</span><a class="headerlink" href="#id44" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="30%" />
<col width="13%" />
<col width="12%" />
<col width="12%" />
<col width="13%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2">Operating Frequency (MHz)</th>
<th class="head" colspan="4">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">BRAM</th>
<th class="head">DSP</th>
<th class="head">CLB
Registers</th>
<th class="head">CLB
LUT</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 Pixel</td>
<td>150</td>
<td>111</td>
<td>302</td>
<td>42504</td>
<td>44000</td>
</tr>
</tbody>
</table>
<p class="rubric">Performance Estimate</p>
<p>The following table summarizes the performance of the ISP all_in_one in 1-pixel
mode as generated using Vitis HLS 2023.1 tool on ZCU102 board.</p>
<p>Estimated average latency is obtained by running the accel with four iterations.
The input to the accel is a 12-bit non-linearized full-HD (1920x1080) image.</p>
<table border="1" class="docutils" id="id45">
<caption><span class="caption-text">Table: ISP all_in_one Performance Estimate Summary</span><a class="headerlink" href="#id45" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Average latency(ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 pixel operation (150 MHz)</td>
<td>22.357</td>
</tr>
</tbody>
</table>
<span class="target" id="isp-24bit"></span></div>
<div class="section" id="isp-24-bit-pipeline">
<h2>ISP 24-bit Pipeline<a class="headerlink" href="#isp-24-bit-pipeline" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>Imaging sensors that do not equip with a high bit-width on the transmission side can be compressed (compand) in a piece-wise linear (PWL) mapping to a lower bit depth.</dt>
<dd>Through the HDR De-companding kernel, the data can be recovered to higher bit-widths and processed through further kernels of ISP by converting to 14-bit for efficient use of resources.</dd>
</dl>
<p>This ISP 24-bit pipeline includes the following 17 blocks:</p>
<blockquote>
<div><ul class="simple">
<li>HDR Decompand</li>
<li>ConvertTo</li>
<li>RGBIR</li>
<li>Auto Exposure Correction(AEC)</li>
<li>Black level correction</li>
<li>Bad pixel correction</li>
<li>Degamma</li>
<li>Lens shading correction</li>
<li>Gain Control</li>
<li>Demosaicing</li>
<li>Tone Mapping</li>
<li>Auto white balance</li>
<li>ISP Stats</li>
<li>Colorcorrection matrix</li>
<li>Gamma correction</li>
<li>3D LUT</li>
<li>Color space conversion</li>
</ul>
</div></blockquote>
<p>The current design example demonstrates how to use ISP functions in a pipeline.</p>
<a class="image reference internal image-reference" href="_images/block_diagram_24bit.png"><img alt="_images/block_diagram_24bit.png" class="image" src="_images/block_diagram_24bit.png" style="width: 1000px;" /></a>
<p>The following table describes the parameters of the pipeline which can be configured dynamically.</p>
<table border="1" class="docutils" id="id46">
<caption><span class="caption-text">Table: Runtime Parameter for the Pipeline</span><a class="headerlink" href="#id46" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><strong>Parameter</strong></th>
<th class="head"><strong>Descriptions</strong></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>height</td>
<td>The number of rows in the image
or height of the image.</td>
</tr>
<tr class="row-odd"><td>width</td>
<td>The number of columns in the
image or width of the image.</td>
</tr>
<tr class="row-even"><td>rgain</td>
<td>To configure gain value for the
red channel.</td>
</tr>
<tr class="row-odd"><td>bgain</td>
<td>To configure gain value for the
blue channel.</td>
</tr>
<tr class="row-even"><td>R_IR_C1_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation1</td>
</tr>
<tr class="row-odd"><td>R_IR_C2_wgts</td>
<td>5x5 Weights to calculate R at IR
location for constellation2</td>
</tr>
<tr class="row-even"><td>B_at_R_wgts</td>
<td>5x5 Weights to calculate B at R
location</td>
</tr>
<tr class="row-odd"><td>IR_at_R_wgts</td>
<td>3x3 Weights to calculate IR at R
location</td>
</tr>
<tr class="row-even"><td>IR_at_B_wgts</td>
<td>3x3 Weights to calculate IR at B
location</td>
</tr>
<tr class="row-odd"><td>sub_wgts</td>
<td>Weights to perform weighted
subtraction of IR image from RGB
image. sub_wgts[0] -&gt; G Pixel,
sub_wgts[1] -&gt; R Pixel,
sub_wgts[2] -&gt; B Pixel
sub_wgts[3] -&gt; calculated B Pixel</td>
</tr>
<tr class="row-even"><td>bayerp</td>
<td>Input Bayer pattern. XF_BAYER_BG,
XF_BAYER_GB, XF_BAYER_GR, XF_BAYER_RG
are the supported values.</td>
</tr>
<tr class="row-odd"><td>params</td>
<td>consists of slope and intercept
values of four knee points in hdr
decompand kernel for R, G, B.</td>
</tr>
<tr class="row-even"><td>params_14bit</td>
<td>consists of slope and intercept
values of four knee points to
truncate 24bit to 14bit.</td>
</tr>
<tr class="row-odd"><td>params_degamma</td>
<td>consists of slope and intercept
values of knee points till 64 to
linearize the image.</td>
</tr>
<tr class="row-even"><td>paec</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality in AEC.</td>
</tr>
<tr class="row-odd"><td>pawb</td>
<td>%top and %bottom pixels are
ignored while computing min and
max to improve quality in AWB.</td>
</tr>
<tr class="row-even"><td>aec_stats</td>
<td>Calculted histogram of the AEC input image.</td>
</tr>
<tr class="row-odd"><td>awb_stats</td>
<td>Calculted histogram of the AWB input image.</td>
</tr>
<tr class="row-even"><td>aec_max_bins</td>
<td>List of maximum values per range of bins.
This is only applicable if merge bins feature
is enabled.</td>
</tr>
<tr class="row-odd"><td>awb_max_bins</td>
<td>List of maximum values per range of bins.
This is only applicable if merge bins feature
is enabled.</td>
</tr>
<tr class="row-even"><td>roi_tlx</td>
<td>Top left x coordinate of ROI</td>
</tr>
<tr class="row-odd"><td>roi_tly</td>
<td>Top left y coordinate of ROI</td>
</tr>
<tr class="row-even"><td>roi_brx</td>
<td>Bottom right x coordinate of ROI</td>
</tr>
<tr class="row-odd"><td>roi_bry</td>
<td>Bottom right y coordinate of ROI</td>
</tr>
<tr class="row-even"><td>zone_col_num</td>
<td>Number of zones across column.</td>
</tr>
<tr class="row-odd"><td>zone_row_num</td>
<td>Number of zones across rows.</td>
</tr>
<tr class="row-even"><td>blk_height</td>
<td>Actual block height</td>
</tr>
<tr class="row-odd"><td>blk_width</td>
<td>Actual block width</td>
</tr>
<tr class="row-even"><td>c1</td>
<td>To retain the details in bright
area using, c1 in the tone
mapping.</td>
</tr>
<tr class="row-odd"><td>c2</td>
<td>Efficiency factor, ranges from
0.5 to 1 based on output device
dynamic range.</td>
</tr>
<tr class="row-even"><td>gamma_lut</td>
<td>Lookup table for gamma
values.first 256 will be R, next
256 values are G gamma and last
256 values are B values</td>
</tr>
<tr class="row-odd"><td>lutDim</td>
<td>Dimension of input lut</td>
</tr>
</tbody>
</table>
<p>The following table describes the template parameters which can be configured.</p>
<table border="1" class="docutils" id="id47">
<caption><span class="caption-text">Table: Compile Time Parameters</span><a class="headerlink" href="#id47" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>XF_HEIGHT</td>
<td>Maximum height of input and output image</td>
</tr>
<tr class="row-odd"><td>XF_WIDTH</td>
<td>Maximum width of input and output image
(Must be multiple of NPC)</td>
</tr>
<tr class="row-even"><td>XF_INP_T</td>
<td>Input pixel type,Supported pixel widths are 8,10,12,16</td>
</tr>
<tr class="row-odd"><td>XF_BAYER_PATTERN</td>
<td>The Bayer format of the RAW input  image.
Supported formats are BGGR, GRBG and GBRG.</td>
</tr>
<tr class="row-even"><td>BLACK_LEVEL</td>
<td>black level value.</td>
</tr>
<tr class="row-odd"><td>DEGAMMA_KP</td>
<td>Number of knee points in degamma.</td>
</tr>
<tr class="row-even"><td>MAX_ZONES</td>
<td>Maximum number of possible zones.</td>
</tr>
<tr class="row-odd"><td>STATS_SIZE</td>
<td>Number of bins per channel for the input image.
This is equal to the number of output bins if
merge bins feature is disabled.</td>
</tr>
<tr class="row-even"><td>FINAL_BINS_NUM</td>
<td>Number of output bins per channel if merge
bins feature is enabled.</td>
</tr>
<tr class="row-odd"><td>MERGE_BINS</td>
<td>To disable or enable merge bins feature.</td>
</tr>
<tr class="row-even"><td>SQLUTDIM</td>
<td>Squared value of maximum dimension of input LUT</td>
</tr>
<tr class="row-odd"><td>LUTDIM</td>
<td>33x33 dimension of input LUT</td>
</tr>
</tbody>
</table>
<p>The following example demonstrates the ISP pipeline with the above list of functions.</p>
<div class="code c highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="n">void</span> <span class="n">ISPpipeline</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_inp</span><span class="p">,</span>
                             <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out</span><span class="p">,</span>
                             <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">OUTPUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">img_out_ir</span><span class="p">,</span>
                             <span class="n">unsigned</span> <span class="n">short</span> <span class="n">height</span><span class="p">,</span>
                             <span class="n">unsigned</span> <span class="n">short</span> <span class="n">width</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">48</span><span class="p">,</span> <span class="mi">24</span><span class="o">&gt;</span> <span class="n">params_14bit</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">R_IR_C1_wgts</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">R_IR_C2_wgts</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">B_at_R_wgts</span><span class="p">[</span><span class="mi">25</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">IR_at_R_wgts</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">IR_at_B_wgts</span><span class="p">[</span><span class="mi">9</span><span class="p">],</span>
                             <span class="n">char</span> <span class="n">sub_wgts</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
                             <span class="n">unsigned</span> <span class="n">short</span> <span class="n">bayerp</span><span class="p">,</span>
                             <span class="n">uint16_t</span> <span class="n">rgain</span><span class="p">,</span>
                             <span class="n">uint16_t</span> <span class="n">bgain</span><span class="p">,</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">32</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">params_degamma</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">DEGAMMA_KP</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span>
                             <span class="n">uint32_t</span> <span class="n">aec_hist0</span><span class="p">[</span><span class="n">HIST_SIZE_AEC</span><span class="p">],</span>    <span class="o">/*</span> <span class="n">function_aec</span> <span class="o">*/</span>
                             <span class="n">uint32_t</span> <span class="n">aec_hist1</span><span class="p">[</span><span class="n">HIST_SIZE_AEC</span><span class="p">],</span>    <span class="o">/*</span> <span class="n">function_aec</span> <span class="o">*/</span>
                             <span class="n">uint32_t</span> <span class="n">awb_hist0</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">HIST_SIZE_AWB</span><span class="p">],</span> <span class="o">/*</span> <span class="n">function_awb</span> <span class="o">*/</span>
                             <span class="n">uint32_t</span> <span class="n">awb_hist1</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">HIST_SIZE_AWB</span><span class="p">],</span> <span class="o">/*</span> <span class="n">function_awb</span> <span class="o">*/</span>
                             <span class="nb">int</span> <span class="n">gain0</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>                         <span class="o">/*</span> <span class="n">function_awb</span> <span class="o">*/</span>
                             <span class="nb">int</span> <span class="n">gain1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>                         <span class="o">/*</span> <span class="n">function_awb</span> <span class="o">*/</span>
                             <span class="n">uint16_t</span> <span class="n">paec</span><span class="p">,</span>
                             <span class="n">uint16_t</span> <span class="n">pawb</span><span class="p">,</span>
                             <span class="n">unsigned</span> <span class="nb">int</span><span class="o">*</span> <span class="n">aec_stats</span><span class="p">,</span>
                             <span class="n">unsigned</span> <span class="nb">int</span><span class="o">*</span> <span class="n">awb_stats</span><span class="p">,</span>
                             <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;*</span> <span class="n">aec_max_bins</span><span class="p">,</span>
                             <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;*</span> <span class="n">awb_max_bins</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">roi_tlx</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">roi_tly</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">roi_brx</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">roi_bry</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">zone_col_num</span><span class="p">,</span> <span class="o">//</span> <span class="n">N</span>
                             <span class="nb">int</span> <span class="n">zone_row_num</span><span class="p">,</span> <span class="o">//</span> <span class="n">M</span>
                             <span class="n">unsigned</span> <span class="n">char</span> <span class="n">gamma_lut</span><span class="p">[</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">3</span><span class="p">],</span>
                             <span class="n">XF_CTUNAME</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)</span> <span class="n">omin_r</span><span class="p">[</span><span class="n">MinMaxVArrSize</span><span class="p">][</span><span class="n">MinMaxHArrSize</span><span class="p">],</span> <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="n">XF_CTUNAME</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)</span> <span class="n">omax_r</span><span class="p">[</span><span class="n">MinMaxVArrSize</span><span class="p">][</span><span class="n">MinMaxHArrSize</span><span class="p">],</span> <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="n">XF_CTUNAME</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)</span> <span class="n">omin_w</span><span class="p">[</span><span class="n">MinMaxVArrSize</span><span class="p">][</span><span class="n">MinMaxHArrSize</span><span class="p">],</span> <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="n">XF_CTUNAME</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)</span> <span class="n">omax_w</span><span class="p">[</span><span class="n">MinMaxVArrSize</span><span class="p">][</span><span class="n">MinMaxHArrSize</span><span class="p">],</span> <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="nb">int</span> <span class="n">blk_height</span><span class="p">,</span>                                                       <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="nb">int</span> <span class="n">blk_width</span><span class="p">,</span>                                                        <span class="o">/*</span> <span class="n">LTM</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">mean1</span><span class="p">,</span>                                              <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">mean2</span><span class="p">,</span>                                              <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">L_max1</span><span class="p">,</span>                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">L_max2</span><span class="p">,</span>                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">L_min1</span><span class="p">,</span>                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_ufixed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">L_min2</span><span class="p">,</span>                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="nb">float</span> <span class="n">c1</span><span class="p">,</span>                                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="nb">float</span> <span class="n">c2</span><span class="p">,</span>                                                             <span class="o">/*</span> <span class="n">gtm</span> <span class="o">*/</span>
                             <span class="n">ap_uint</span><span class="o">&lt;</span><span class="n">LUT_PTR_WIDTH</span><span class="o">&gt;*</span> <span class="n">lut</span><span class="p">,</span>
                             <span class="nb">int</span> <span class="n">lutDim</span><span class="p">)</span> <span class="p">{</span>

                    <span class="c1">#pragma HLS INLINE OFF</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_INP_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span> <span class="n">imgInput1</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_HDR_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_hdr_out</span><span class="o">&gt;</span> <span class="n">hdr_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_hdr_out</span><span class="o">&gt;</span> <span class="n">img_14bit</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rggb_out</span><span class="o">&gt;</span> <span class="n">rggb_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aecin</span><span class="o">&gt;</span> <span class="n">aec_in1</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aecin</span><span class="o">&gt;</span> <span class="n">aec_in2</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aec_out</span><span class="o">&gt;</span> <span class="n">aec_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_bpc_out</span><span class="o">&gt;</span> <span class="n">bpc_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_blc_out</span><span class="o">&gt;</span> <span class="n">blc_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dgamma_out</span><span class="o">&gt;</span> <span class="n">dgamma_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_lsc_out</span><span class="o">&gt;</span> <span class="n">LscOut</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_gain_out</span><span class="o">&gt;</span> <span class="n">gain_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_demosaic_out</span><span class="o">&gt;</span> <span class="n">demosaic_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ltm_out</span><span class="o">&gt;</span> <span class="n">ltm_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awb_out</span><span class="o">&gt;</span> <span class="n">awb_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awbin</span><span class="o">&gt;</span> <span class="n">awb_in1</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awbin</span><span class="o">&gt;</span> <span class="n">awb_in2</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dst</span><span class="o">&gt;</span> <span class="n">gamma_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ccm</span><span class="o">&gt;</span> <span class="n">ccm_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Mat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_lut_out</span><span class="o">&gt;</span> <span class="n">lut_out</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>

            <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">off</span>
            <span class="c1">#pragma HLS DATAFLOW</span>
                    <span class="o">//</span> <span class="n">clang</span><span class="o">-</span><span class="nb">format</span> <span class="n">on</span>

                    <span class="nb">float</span> <span class="n">awb_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">pawb</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">aec_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="n">paec</span> <span class="o">/</span> <span class="mi">256</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">inputMax</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">XF_DTPIXELDEPTH</span><span class="p">(</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">)))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">//</span> <span class="mf">65535.0</span><span class="n">f</span><span class="p">;</span>

                    <span class="nb">float</span> <span class="n">mul_fact</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputMax</span> <span class="o">/</span> <span class="p">(</span><span class="n">inputMax</span> <span class="o">-</span> <span class="n">BLACK_LEVEL</span><span class="p">));</span>
<span class="n">unsigned</span> <span class="nb">int</span> <span class="n">blc_config_1</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">)(</span><span class="n">mul_fact</span> <span class="o">*</span> <span class="mi">65536</span><span class="p">);</span> <span class="o">//</span> <span class="n">mul_fact</span> <span class="nb">int</span> <span class="n">Q16_16</span> <span class="nb">format</span>
<span class="n">unsigned</span> <span class="nb">int</span> <span class="n">blc_config_2</span> <span class="o">=</span> <span class="n">BLACK_LEVEL</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">inputmin</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">inputmax1</span> <span class="o">=</span> <span class="mf">255.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">outputmin</span> <span class="o">=</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">outputmax1</span> <span class="o">=</span> <span class="mf">255.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">inputmax2</span> <span class="o">=</span> <span class="mf">16383.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">float</span> <span class="n">outputmax2</span> <span class="o">=</span> <span class="mf">16383.0</span><span class="n">f</span><span class="p">;</span>
                    <span class="nb">int</span> <span class="n">outdepth</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">XF_DTPIXELDEPTH</span><span class="p">(</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">));</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Array2xfMat</span><span class="o">&lt;</span><span class="n">INPUT_PTR_WIDTH</span><span class="p">,</span> <span class="n">XF_INP_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_inp</span><span class="p">,</span>
                                                                                                                                                                                                       <span class="n">imgInput1</span><span class="p">);</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">hdr_decompand</span><span class="o">&lt;</span><span class="n">XF_INP_T</span><span class="p">,</span> <span class="n">XF_HDR_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_imgInput</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_hdr_out</span><span class="o">&gt;</span><span class="p">(</span>
                            <span class="n">imgInput1</span><span class="p">,</span> <span class="n">hdr_out</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">bayerp</span><span class="p">);</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">convert24To14bit</span><span class="o">&lt;</span><span class="n">XF_HDR_T</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_hdr_out</span><span class="p">,</span>
                                                                     <span class="n">XF_CV_DEPTH_hdr_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hdr_out</span><span class="p">,</span> <span class="n">img_14bit</span><span class="p">,</span> <span class="n">params_14bit</span><span class="p">,</span> <span class="n">bayerp</span><span class="p">);</span>

                    <span class="n">function_rgbir_or_fifo</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_hdr_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_rggb_out</span><span class="p">,</span>
                                                               <span class="n">XF_CV_DEPTH_rggb_out_ir</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_3XWIDTH</span><span class="o">&gt;</span><span class="p">(</span><span class="n">img_14bit</span><span class="p">,</span> <span class="n">rggb_out</span><span class="p">,</span> <span class="n">img_out_ir</span><span class="p">,</span> <span class="n">R_IR_C1_wgts</span><span class="p">,</span>
                                                                                                                                                             <span class="n">R_IR_C2_wgts</span><span class="p">,</span> <span class="n">B_at_R_wgts</span><span class="p">,</span> <span class="n">IR_at_R_wgts</span><span class="p">,</span>
                                                                                                                                                             <span class="n">IR_at_B_wgts</span><span class="p">,</span> <span class="n">sub_wgts</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>

                    <span class="n">function_aec</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aecin</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aec_out</span><span class="o">&gt;</span><span class="p">(</span>
                            <span class="n">rggb_out</span><span class="p">,</span> <span class="n">aec_out</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">aec_thresh</span><span class="p">,</span> <span class="n">aec_hist0</span><span class="p">,</span> <span class="n">aec_hist1</span><span class="p">);</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">blackLevelCorrection</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_aec_out</span><span class="p">,</span>
                                                                             <span class="n">XF_CV_DEPTH_blc_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">aec_out</span><span class="p">,</span> <span class="n">blc_out</span><span class="p">,</span> <span class="n">blc_config_2</span><span class="p">,</span> <span class="n">blc_config_1</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">badpixelcorrection</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_blc_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_bpc_out</span><span class="o">&gt;</span><span class="p">(</span>
                            <span class="n">blc_out</span><span class="p">,</span> <span class="n">bpc_out</span><span class="p">);</span>

                    <span class="n">function_degamma</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_bpc_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dgamma_out</span><span class="p">,</span>
                                                     <span class="n">DEGAMMA_KP</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bpc_out</span><span class="p">,</span> <span class="n">dgamma_out</span><span class="p">,</span> <span class="n">params_degamma</span><span class="p">,</span> <span class="n">bayerp</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">Lscdistancebased</span><span class="o">&lt;</span><span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dgamma_out</span><span class="p">,</span>
                                                                     <span class="n">XF_CV_DEPTH_lsc_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">dgamma_out</span><span class="p">,</span> <span class="n">LscOut</span><span class="p">);</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">gaincontrol</span><span class="o">&lt;</span><span class="n">XF_BAYER_PATTERN</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_lsc_out</span><span class="p">,</span>
                                                            <span class="n">XF_CV_DEPTH_gain_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LscOut</span><span class="p">,</span> <span class="n">gain_out</span><span class="p">,</span> <span class="n">rgain</span><span class="p">,</span> <span class="n">bgain</span><span class="p">);</span>

                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">demosaicing</span><span class="o">&lt;</span><span class="n">XF_BAYER_PATTERN</span><span class="p">,</span> <span class="n">XF_SRC_T</span><span class="p">,</span> <span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_gain_out</span><span class="p">,</span>
                                                            <span class="n">XF_CV_DEPTH_demosaic_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gain_out</span><span class="p">,</span> <span class="n">demosaic_out</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">XF_DST_T</span> <span class="o">==</span> <span class="n">XF_8UC3</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">fifo_copy</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_demosaic_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ltm_out</span><span class="o">&gt;</span><span class="p">(</span>
                                    <span class="n">demosaic_out</span><span class="p">,</span> <span class="n">ltm_out</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="n">function_tm</span><span class="o">&lt;</span><span class="n">XF_DST_T</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_demosaic_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ltm_out</span><span class="o">&gt;</span><span class="p">(</span>
                                    <span class="n">demosaic_out</span><span class="p">,</span> <span class="n">ltm_out</span><span class="p">,</span> <span class="n">omin_r</span><span class="p">,</span> <span class="n">omax_r</span><span class="p">,</span> <span class="n">omin_w</span><span class="p">,</span> <span class="n">omax_w</span><span class="p">,</span> <span class="n">blk_height</span><span class="p">,</span> <span class="n">blk_width</span><span class="p">,</span> <span class="n">mean1</span><span class="p">,</span> <span class="n">mean2</span><span class="p">,</span> <span class="n">L_max1</span><span class="p">,</span> <span class="n">L_max2</span><span class="p">,</span>
                                    <span class="n">L_min1</span><span class="p">,</span> <span class="n">L_min2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">duplicateMat</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ltm_out</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awbin</span><span class="p">,</span>
                                                             <span class="n">XF_CV_DEPTH_awbin</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ltm_out</span><span class="p">,</span> <span class="n">awb_in1</span><span class="p">,</span> <span class="n">awb_in2</span><span class="p">);</span>

                    <span class="n">function_awb</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awbin</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awb_out</span><span class="o">&gt;</span><span class="p">(</span>
                            <span class="n">awb_in1</span><span class="p">,</span> <span class="n">awb_out</span><span class="p">,</span> <span class="n">awb_hist0</span><span class="p">,</span> <span class="n">awb_hist1</span><span class="p">,</span> <span class="n">gain0</span><span class="p">,</span> <span class="n">gain1</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">awb_thresh</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">ispStats</span><span class="o">&lt;</span><span class="n">MAX_ZONES</span><span class="p">,</span> <span class="n">STATS_SIZE_AWB</span><span class="p">,</span> <span class="n">FINAL_BINS_NUM</span><span class="p">,</span> <span class="n">MERGE_BINS</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">NUM_OUT_CH</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span>
                                                     <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awbin</span><span class="o">&gt;</span><span class="p">(</span><span class="n">awb_in2</span><span class="p">,</span> <span class="n">awb_stats</span><span class="p">,</span> <span class="n">awb_max_bins</span><span class="p">,</span> <span class="n">roi_tlx</span><span class="p">,</span> <span class="n">roi_tly</span><span class="p">,</span> <span class="n">roi_brx</span><span class="p">,</span> <span class="n">roi_bry</span><span class="p">,</span>
                                                                                                             <span class="n">zone_col_num</span><span class="p">,</span> <span class="n">zone_row_num</span><span class="p">,</span> <span class="n">inputmin</span><span class="p">,</span> <span class="n">inputmax1</span><span class="p">,</span> <span class="n">outputmin</span><span class="p">,</span>
                                                                                                             <span class="n">outputmax1</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">colorcorrectionmatrix</span><span class="o">&lt;</span><span class="n">XF_CCM_TYPE</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_awb_out</span><span class="p">,</span>
                                                                              <span class="n">XF_CV_DEPTH_ccm</span><span class="o">&gt;</span><span class="p">(</span><span class="n">awb_out</span><span class="p">,</span> <span class="n">ccm_out</span><span class="p">);</span>
                    <span class="n">xf</span><span class="p">::</span><span class="n">cv</span><span class="p">::</span><span class="n">gammacorrection</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_ccm</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dst</span><span class="o">&gt;</span><span class="p">(</span>
                            <span class="n">ccm_out</span><span class="p">,</span> <span class="n">gamma_out</span><span class="p">,</span> <span class="n">gamma_lut</span><span class="p">);</span>

                    <span class="n">function_3dlut_fifo</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_dst</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_lut_out</span><span class="p">,</span>
                                                            <span class="n">XF_CV_DEPTH_3dlut</span><span class="o">&gt;</span><span class="p">(</span><span class="n">gamma_out</span><span class="p">,</span> <span class="n">lut_out</span><span class="p">,</span> <span class="n">lut</span><span class="p">,</span> <span class="n">lutDim</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
                    <span class="n">function_csc_or_mat_array</span><span class="o">&lt;</span><span class="n">XF_GTM_T</span><span class="p">,</span> <span class="n">XF_HEIGHT</span><span class="p">,</span> <span class="n">XF_WIDTH</span><span class="p">,</span> <span class="n">XF_NPPC</span><span class="p">,</span> <span class="n">XF_CV_DEPTH_lut_out</span><span class="o">&gt;</span><span class="p">(</span><span class="n">lut_out</span><span class="p">,</span> <span class="n">img_out</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span>
                                                                                                                                                                                               <span class="n">width</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The ISP 24bit Pipeline design is validated on zcu102 board at 150 MHz frequency.</p>
<table border="1" class="docutils" id="id48">
<caption><span class="caption-text">Table: Resource Utilization Summary for a 1920x1080 Image</span><a class="headerlink" href="#id48" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="18%" />
<col width="23%" />
<col width="18%" />
<col width="14%" />
<col width="12%" />
<col width="9%" />
<col width="7%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2"><p class="first">Operating Frequency</p>
<p class="last">(MHz)</p>
</th>
<th class="head" colspan="5">Utilization Estimate</th>
</tr>
<tr class="row-even"><th class="head">LUT</th>
<th class="head">FF</th>
<th class="head">BRAM_18k</th>
<th class="head">DSP</th>
<th class="head">URAM</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 Pixel</td>
<td>150</td>
<td>35734</td>
<td>38747</td>
<td>60</td>
<td>275</td>
<td>0</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils" id="id49">
<caption><span class="caption-text">Table: Performance Estimate Summary for a 1920x1080 Image</span><a class="headerlink" href="#id49" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="29%" />
<col width="38%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Operating Mode</th>
<th class="head" rowspan="2"><p class="first">Operating Frequency</p>
<p class="last">(MHz)</p>
</th>
<th class="head">Latency Estimate</th>
</tr>
<tr class="row-even"><th class="head">Max (ms)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>1 pixel</td>
<td>150</td>
<td>15.1ms</td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Atalwar: Moved the footer code to layout.html to resolve conflict with the Xilinx template -->
</footer>

        </div>
      </div>


	  <!-- Sphinx Page Footer block -->
  

  <hr/>

  <div role="contentinfo" class="copyright">
    <p class="footerinfo">
      <span class="lastupdated">
        Last updated on May 28, 2024.
      </span>

    </p>
	<br>
  </div>
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

   <script type="text/javascript">
    jQuery(function() { Search.loadIndex("searchindex.js"); });
  </script>

  <script type="text/javascript" id="searchindexloader"></script>


  
  
    
  



  <!--  Xilinx template footer block -->
							</div>
						</div>
					</div>
				</div>
				<div class="xilinxExperienceFragments experiencefragment aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
					<div class="xf-content-height">
						<div class="aem-Grid aem-Grid--16 aem-Grid--default--16 ">
							<div class="footer parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16">
								<noindex>
                  <!-- make footer fixed - NileshP -->
                  <style>
                        .footer {
                        position: fixed;
                        left: 0;
                        bottom: 0;
                        width: 100%;
                        }
                  </style>
                  <!-- make footer fixed NileshP-->
									<footer>
										<div class="aem-Grid aem-Grid--16">
											<div class="aem-GridColumn aem-GridColumn--xxxlarge--none aem-GridColumn--xsmall--16 aem-GridColumn--offset--xsmall--0 aem-GridColumn--xlarge--none aem-GridColumn--xxlarge--none aem-GridColumn--default--none aem-GridColumn--offset--large--1 aem-GridColumn--xlarge--12 aem-GridColumn--offset--default--0 aem-GridColumn--xxlarge--10 aem-GridColumn--offset--xlarge--2 aem-GridColumn--offset--xxlarge--3 aem-GridColumn--offset--xxxlarge--4 aem-GridColumn--xsmall--none aem-GridColumn--large--none aem-GridColumn aem-GridColumn--large--14 aem-GridColumn--xxxlarge--8 aem-GridColumn--default--16">
												<div class="container-fluid sub-footer">
													<div class="row">
														<div class="footerSocial parbase">
														
															<div class="col-md-push-6 col-lg-push-6 col-md-6 col-lg-6">
																<div class="lang-select dropup hidden-md hidden-lg">
		<button data-toggle="dropdown">
			<span class="fas fa-globe" aria-hidden="true"></span>
			<span>
				
					English
				</span>
		<span class="far fa-angle-down" aria-hidden="true"></span>
	</button>
	<ul class="dropdown-menu">
		<li>
				<a target="_blank" href="https://japan.xilinx.com/" target="_self">
					日本語
				</a>
			</li>
		<li>
				<a target="_blank" href="https://china.xilinx.com/" target="_self">
					简体中文
				</a>
			</li>
		</ul>
	</div>
																<ul class="list-inline pull-right social-menu">
																	<li>
																		<a target="_blank" href="https://www.linkedin.com/company/xilinx">
																		<span class="linkedin icon"></span>
																		<span class="sr-only">Connect on LinkedIn</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.twitter.com/XilinxInc">
																		<span class="twitter icon"></span>
																		<span class="sr-only">Follow us on Twitter</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.facebook.com/XilinxInc">
																		<span class="facebook icon"></span>
																		<span class="sr-only">Connect on Facebook</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.youtube.com/XilinxInc">
																		<span class="youtube icon"></span>
																		<span class="sr-only">Watch us on YouTube</span>
																		</a>
																	</li>
																	<li>
																		<a target="_blank" href="https://www.xilinx.com/registration/subscriber-signup.html">
																		<span class="newsletter icon"></span>
																		<span class="sr-only">Subscribe to Newsletter</span>
																		</a>
																	</li>
																</ul>
																	<div class="lang-select dropup hidden-xs hidden-sm">
	<button data-toggle="dropdown">
		<span class="fas fa-globe" aria-hidden="true"></span>
		<span>
			
				English
			</span>
		<span class="far fa-angle-down" aria-hidden="true"></span>
	</button>
	<ul class="dropdown-menu">
		<li>
				<a target="_blank" href="https://japan.xilinx.com/" target="_self">
					日本語
				</a>
			</li>
		<li>
				<a target="_blank" href="https://china.xilinx.com/" target="_self">
					简体中文
				</a>
			</li>
		</ul>
	</div>
															</div>
														</div>
														<div class="col-md-pull-5 col-lg-pull-5 col-md-5 col-lg-5">
															<span class="copyright">©2022 Advanced Micro Devices, Inc</span>
														</div>

													</div>
													                    <div class="movethisrowtoleft row">
                        <div class="col-xs-24">
                            <ul class="sub-menu">
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/copyright">Terms and Conditions</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/privacy">Privacy</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/cookies">Cookie Policy</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/trademarks">Trademarks</a></li>
                                <li><a target="_blank" href="https://www.amd.com/system/files/documents/statement-human-trafficking-forced-labor.pdf">Statement on Forced Labor</a></li>
                                <li><a target="_blank" href="https://www.amd.com/en/corporate/competition">Fair and Open Competition</a></li>
                                <li><a target="_blank" href="https://www.amd.com/system/files/documents/amd-uk-tax-strategy.pdf">UK Tax Strategy</a></li>
								<li><a target="_blank" href="https://docs.xilinx.com/v/u/9x6YvZKuWyhJId7y7RQQKA">Inclusive Terminology</a></li>
                                <li><a href="#cookiessettings" class="ot-sdk-show-settings">Cookies Settings</a></li>
                            </ul>
                        </div>
                    </div>
												</div>
											</div>
										</div>
									</footer>
								</noindex>
							</div>
						</div>
					</div>
				</div>
<div class="backToTop parbase aem-GridColumn--default--none aem-GridColumn aem-GridColumn--offset--default--0 aem-GridColumn--default--16"><noindex>
    <span data-component="backToTopButton" class="backToTopButton loaded">
        <ul>
            <li>
                <a href="https://www.author.xilinx.com/xx/rebrand/amd/en-amd-xilinx-header-footer.html#top" class="btn top">
                    <span class="fas fa-angle-up" aria-hidden="true"></span>
                </a>
            </li>
        </ul>
    </span>
</noindex></div>
			</div>
		</div>


		<script>window.CQ = window.CQ || {}</script>
		<script src="https://static.cloud.coveo.com/searchui/v2.4382/js/CoveoJsSearch.Lazy.min.js"></script>
		<script>
			var underscoreSetup = function () {
			  _.templateSettings.interpolate = /\{\{=([^-][\S\s]+?)\}\}/g;
			  _.templateSettings.evaluate = /\{\{([^-=][\S\s]+?)\}\}/g;
			  _.templateSettings.escape = /\{\{-([^=][\S\s]+?)\}\}/g;
			}

			underscoreSetup();
		</script>
	</body>
</html>